Terraform is an open-source infrastructure as code (IaC) tool used for building and managing cloud and on-premises infrastructure.
Developed by HashiCorp, Terraform allows users to define and version infrastructure configurations in human-readable configuration files,
which can then be used to create and manage virtual machines, networks, and other resources on various cloud and on-premises platforms. 
Terraform supports a wide range of providers, including AWS, Azure, Google Cloud, and many others,
making it a popular choice for organizations seeking to standardize and automate their infrastructure management processes.

#######################################################################

terraform variables

Using variables in terraform configurations makes our deployment more dynamic.
A separate file with name variables.tf needs to be created in the working directory to store all variables fro our used in main.tf configuration file.

Terraform variables are values that can be used to customize the behavior of Terraform configurations throughout a workspace.
These values are stored in a variables.tf file and can be used to parameterize infrastructure as code. 
There are two types of variables in Terraform: local and input. 
Local variables are only accessible within the scope of the module or configuration they are declared in, while input variables are available throughout the entire workspace. 
Terraform variables can be set through command-line options, environment variables, or a variables.tf file.


#############################################################################

StateFile:

A Terraform state file is a JSON file that stores information about resources in your infrastructure, such as their IDs, 
attributes, and dependencies. It's created after running terraform apply and is usually named terraform.
tfstate and located in the same directory as Terraform. 

Terraform uses the state file to: 
Track resource state: Accurately account for the current state of your infrastructure 
Manage resource dependencies: Understand how resources depend on each other 
Plan and apply operations: Compare the desired state (your configuration) to the current state (the state file) 
Improve performance: Optimize performance for large infrastructures 
The state file contains information such as: 
Resource information: Resource IDs, attributes (like IP addresses and security group rules), and dependencies 
Metadata: Resource names, tags, and other configuration details 
Version: The Terraform version 
Serial: The serial 
Lineage: The lineage 
Outputs: The outputs 
Some recommend storing state in HCP Terraform to version, encrypt, and securely share it with your team. 
Terraform also uses a lock on the state file to prevent concurrent modifications that could lead to conflicts or data corruption.

##################################################################

Restoring statefile:

If the statefile is deleted or corrupted ,we can restore it using Terraform import command.

The terraform import command is used to import an existing infrastructure resource from a cloud or on-premises environment into a Terraform configuration. 
This command allows you to manage existing resources alongside newly created ones within your Terraform state.
The command syntax is terraform import <resource> <id>, where <resource> is the resource type and <id> is a unique identifier
of the resource. For example, terraform import aws_instance.web i-abc123 would import an AWS EC2 instance with the ID i-abc123 into your Terraform configuration.

     terraform import azurerm_subnet_network_security_group_association.association1 /subscriptions/00000000-0000-0000-0000-000000000000/resourceGroups/mygroup1/providers/Microsoft.Network/virtualNetworks/myvnet1/subnets/mysubnet1
      terraform import resource name resource id
######################################################################################

Terraform remote backend or remote statefile:

Terraform's remote backend and remote state are both ways to store Terraform state in a remote location, like a database or cloud object storage service.

When working with Terraform, a remote backend allows you to store and manage your infrastructure state remotely,
rather than on your local machine. This provides several benefits, including improved collaboration, version control, and disaster recovery.
A remote state file is a file stored in the remote backend, which contains the current state of your infrastructure. 
Popular remote backend options include AWS S3, Azure Blob Storage, and Google Cloud Storage. 
By using a remote backend, you can ensure that your infrastructure state is always synchronized and accessible from anywhere.

############################################################################################

How do I store Terraform state file remotely?

Storing Terraform state files remotely is a best practice for collaboration, security, and disaster recovery.
Remote storage ensures that the state file is accessible to all team members and is safely stored away from local machines.

Here are the steps on how to store Terraform state file on Terraform cloud Remote:
Create a Terraform Cloud organization and workspace.
Create a configuration file that defines the resources you want to create.
Initialize Terraform.
Configure Terraform Cloud to store the state file.
Authentication with Terraform Cloud.

terraform {
  backend "s3" {
    bucket         = "my-terraform-state"
    key            = "path/to/my-state-file/terraform.tfstate"
    region         = "us-east-1"
    dynamodb_table = "terraform-locks" # Optional for state locking
  }
}


##################################################################################################
Terraform state lock:

Terraform state locking is a safety mechanism that prevents data corruption and conflicts by ensuring 
that only one user or process can modify the Terraform state file at a time. 
It works by automatically locking the state for all operations that could write to it. 

In multi-user or automated environments where multiple processes may attempt to apply Terraform configurations simultaneously,
a state lock ensures that only one operation modifies the state at a time.
DynamoDB's atomic item locking capability makes it ideal for implementing this functionality. 
Terraform uses the DynamoDB LockID to ensure that no two operations can lock the state simultaneously.

In AWS S3 is used to store our statefile and DynamoDB is used for state lock

terraform {
  backend "s3" {
    bucket         = "my-terraform-state"
    key            = "path/to/my-state-file/terraform.tfstate"
    region         = "us-east-1"
    dynamodb_table = "terraform-locks" # Optional for state locking
  }
}

###################################################################################################
data sources in terraform

In Terraform, data sources are used to retrieve information from external sources, such as AWS, Azure, or a local file.
They allow you to store and retrieve data that's not easily captured by a Terraform resource. 
Common data sources include AWS EC2 instance ids, Azure storage account names, and local files.
To use a data source in Terraform, you declare it in your Terraform configuration file using the data keyword, followed by the type of data source and its arguments.

A data source is used to query information from external systems or existing resources and incorporate that information into our Terraform configuration.
It provides dynamic attributes that can be used to make our configurations context-aware and responsive to changes.

data "aws_vpc" "main" {
  filter {
    name   = "tag:Name"
    values = ["main-vpc"]
  }
}

output "vpc_id" {
  value = data.aws_vpc.main.id
}


########################################################################################
locals in terraform

In Terraform, locals are a way to define small, reusable blocks of code that can be used within a module or configuration.
They are not stored on disk, unlike variables, and are only available during the planning and applying phases of the Terraform configuration.
Locals can be used to simplify complex expressions, abstract away repetitive constructs, and make your configuration more readable.
They are defined using the local keyword and can be used to store values that are computed or derived from other values in your configuration.

variable "environment" {
  default = "production"
}

variable "owner" {
  default = "DevOps Team"
}

locals {
  aws_region    = "us-east-1"
  common_tags   = {
    Project     = "MyApp"
    Environment = var.environment
    Owner       = var.owner
  }
  instance_type = var.environment == "production" ? "t3.medium" : "t2.micro"
}

provider "aws" {
  region = local.aws_region
}

resource "aws_instance" "web" {
  ami           = "ami-12345678"
  instance_type = local.instance_type

  tags = local.common_tags
}

The expression evaluates whether the var.environment variable equals "production".
If true, it assigns the value "t3.medium" to instance_type.
If false, it assigns the value "t2.micro" to instance_type.


#############################################################################################
provisioners in terraform

Provisioners in Terraform are a way to execute code on a machine after it has been created or updated by Terraform. 
There are 3 types of provisioners: local-exec,Remote-exec and file. 
Local-exec provisioners allow the execution of arbitrary local code on the machine, 
while file provisioners enable the copying of files to the machine. 
Provisioners can be used to configure machines, install software, or perform other tasks.
They can be specified at the resource level, allowing for varying provisioning behavior per resource or group of resources.

##############################################################################################
file provisioner in terraform

A file provisioner in Terraform is a provisioner that copies files from the local file system to a remote server. 
It is used to manage the deployment of files to remote servers, such as configuration files, scripts, or other sensitive data. 
The file provisioner is typically used in combination with other provisioners, such as the script provisioner, to complete the deployment of a server.
There are two types of file provisioners: remote-exec and copy. 
The remote-exec provisioner runs a command on the remote server to copy the file, 
while the copy provisioner copies the file directly from the local file system to the remote server.

resource "aws_instance" "example" {
  ami           = "ami-0c55b159cbfafe1f0"
  instance_type = "t2.micro"
  key_name      = "my-key"

  provisioner "file" {
    source      = "my-script.sh"
    destination = "/tmp/my-script.sh"

    connection {
      type     = "ssh"
      user     = "ubuntu"
      private_key = file("~/.ssh/my-key.pem")
      host     = self.public_ip
    }
  }
}


################################################################
 local-exec provisioner in terraform

The local-exec provisioner in Terraform is a provisioner that runs a command locally on a machine. 
The local-exec provisioner in Terraform is used to execute a command on the machine where Terraform is running. 
It is often employed for tasks such as invoking scripts, running shell commands,
or interacting with local systems during resource creation or destruction.
It allows you to execute arbitrary shell commands after a resource has been created. 
This is useful for tasks that require more control and customization than a provisioner like the remote-exec provisioner, which runs a command remotely on a machine.
The local-exec provisioner can be used to perform tasks such as copying files, or starting services.
You specify the command to run using the command argument.

resource "aws_instance" "example" {
  ami           = "ami-0c55b159cbfafe1f0"
  instance_type = "t2.micro"

  provisioner "local-exec" {
    command = "echo 'SubnetID ${self.subnetid} ' >> subnet_id.txt"
  }
}


###################################################################
remote-exec provisioner in terraform

The remote-exec provisioner in Terraform is a powerful tool that allows you to execute arbitrary commands on a remote resource after it has been created.
This can be useful for tasks such as configuring a newly created server, setting up a service, or installing software. 
The provisioner takes a command to run as its value, and Terraform will execute this command on the remote resource after creation. 
It also supports specifying a command timeout, and the option to run the command in a specific shell. 
This provisioner is commonly used in.tf files to automate post-creation tasks.

resource "aws_instance" "example" {
  ami           = "ami-12345678"
  instance_type = "t2.micro"

  provisioner "remote-exec" {
    inline = [
      "sudo apt-get update -y",
      "sudo apt-get install -y nginx",
      "sudo systemctl start nginx"
    ]

    connection {
      type        = "ssh"
      user        = "ec2-user"
      private_key = file("~/.ssh/id_rsa")
      host        = self.public_ip
    }
  }
}


#########################################################################
 workspace in terraform

In Terraform, a "workspace" refers to a shared environment for a specific project or organization. 
It allows multiple team members to collaborate on infrastructure resources and configurations. 
A workplace is essentially a container that holds all the Terraform configuration files, including state, variables, and outputs.
Within a workplace, you can manage resources, apply configurations, and version control your infrastructure changes. 
This enables teams to work together efficiently, maintaining a consistent and reproducible infrastructure setup.

to view all  available workspaces
terraform workspace list
crete new workspace
terraform workspace new <workspace_name>
switching between
terraform workspace select <workspace_name>
display current ws
terraform workspace show

###########################################################################
service principal in terraform

Here's the information you need about Service Principal in Terraform:

A service principal is a secure way to authenticate with Azure services using Terraform.
It's essentially an identity for your application or service that can be used to access Azure resources. 
In Terraform, you can use the azurerm_service_principal resource to create and manage service principals.
You can also use azurerm_client_config to configure and authenticate your Terraform workflow with a service principal. 
This provides a secure way to manage Azure resources without hardcoding your credentials.
#####################################################################################

Terraform Modules:
Terraform modules are reusable blocks of configuration that allow you to define and manage multiple infrastructure resources as a single unit.
They enable you to break down complex infrastructure deployments into smaller, more manageable pieces, 
promoting modularity and reusability. Examples of Terraform modules include:

A module for creating a virtual private cloud (VPC) with subnets and security groups
A module for provisioning a database cluster with scaling and backup policies
A module for deploying a load balancer with auto-scaling and SSL termination
By using Terraform modules, you can speed up your infrastructure deployments, reduce errors, and improve maintainability.

What is a Terraform module? A Terraform module is a collection of standard configuration files in a dedicated directory. 
Terraform modules encapsulate groups of resources dedicated to one task,
reducing the amount of code you have to develop for similar infrastructure components.


Terraform modules are reusable packages of Terraform configuration that can encapsulate a specific combination of resources and dependencies.
They allow you to break down large infrastructure configurations into smaller, more manageable pieces, making it easier to maintain and reuse code.
Modules can be created and shared by the community, or created internally by your organization.
They can also be used to create consistent infrastructure across multiple environments, such as development, staging, and production. 
By using Terraform modules, you can speed up your infrastructure provisioning process and reduce errors.


module "iam_iam-user" {
  source  = "terraform-aws-modules/iam/aws//modules/iam-user"
  version = "5.28.0"
  # insert the 1 required variable here
  name = "sai"
}

################################################################################################

Terraform Functions:

Terraform functions are built-in utilities that allow you to perform operations like string manipulation, arithmetic, and conditional logic within Terraform configurations. These functions enable more dynamic and reusable infrastructure definitions.

Categories of Terraform Functions
1. String Functions
Work with and manipulate string values.

Function	Description	Example
chomp(string)	Removes trailing newline or carriage return.	chomp("Hello\n") → "Hello"

join(separator, list)	Joins elements of a list into a single string.	join(",", ["a", "b", "c"]) → "a,b,c"

length(string)	Returns the length of a string.	length("hello") → 5

lower(string)	Converts a string to lowercase.	lower("Hello") → "hello"

upper(string)	Converts a string to uppercase.	upper("hello") → "HELLO"

replace(string, search, replace)	Replaces occurrences of a substring.	replace("foo/bar", "/", "-") → "foo-bar"

split(separator, string)	Splits a string into a list.	split(",", "a,b,c") → ["a", "b", "c"]

trimspace(string)	Removes leading and trailing whitespace.	trimspace(" hello ") → "hello"

##########################################################################
2. Numeric Functions
Perform calculations and operations on numbers.

Function	Description	Example
abs(number)	Absolute value of a number.	abs(-5) → 5

ceil(number)	Rounds up to the nearest integer.	ceil(3.1) → 4

floor(number)	Rounds down to the nearest integer.	floor(3.9) → 3

max(numbers...)	Returns the largest number.	max(1, 5, 10) → 10

min(numbers...)	Returns the smallest number.	min(1, 5, 10) → 1

round(number)	Rounds to the nearest integer.	round(3.5) → 4

##############################################################################
3. Collection Functions
Operate on lists, maps, and other collections.

Function	Description	Example
concat(list1, list2)	Combines multiple lists into one.	concat([1, 2], [3, 4]) → [1, 2, 3, 4]

contains(list, value)	Checks if a list contains a value.	contains(["a", "b"], "a") → true

element(list, index)	Returns an element from a list by index.	element(["a", "b"], 1) → "b"

keys(map)	Returns the keys of a map as a list.	keys({a = 1, b = 2}) → ["a", "b"]

length(collection)	Returns the number of elements in a collection.	length(["a", "b"]) → 2

lookup(map, key, default)	Fetches a value from a map or a default value.	lookup({a = 1}, "a", 0) → 1

merge(map1, map2)	Merges two or more maps.	merge({a = 1}, {b = 2}) → {a = 1, b = 2}

slice(list, start, end)	Returns a sublist from a list.	slice(["a", "b", "c"], 0, 2) → ["a", "b"]

#######################################################################################
4. Conditional Functions
Evaluate conditions and return results.

Function	Description	Example
coalesce(values...)	Returns the first non-null value.	coalesce(null, "", "default") → "default"

coalescelist(values...)	Returns the first non-empty list.	coalescelist([], [1], [2]) → [1]

default(value, default)	Returns value if not null, else default.	default(null, "fallback") → "fallback"

#############################################################################################
5. File Functions
Read and manipulate file contents.

Function	Description	Example
file(path)	Reads the content of a file as a string.	file("example.txt") → "file contents"

filebase64(path)	Reads the file as base64-encoded string.	filebase64("image.png") → "base64-string"

#################################################################################################
6. IP and CIDR Functions
Manage IP addresses and CIDR blocks.

Function	Description	Example
cidrhost(cidr, num)	Returns a specific IP address in a CIDR block.	cidrhost("10.0.0.0/16", 5) → "10.0.0.5"

cidrsubnet(cidr, mask, num)	Splits a CIDR block into subnets.	cidrsubnet("10.0.0.0/16", 8, 1) → "10.1.0.0/24"

#########################################################################################################
7. Encoding Functions
Work with base64 encoding.

Function	Description	Example
base64encode(string)	Encodes a string to Base64.	base64encode("hello") → "aGVsbG8="

base64decode(string)	Decodes a Base64-encoded string.	base64decode("aGVsbG8=") → "hello"

##########################################################################################################
8. Date and Time Functions
Handle time-related data.

Function	Description	Example
timestamp()	Returns the current UTC timestamp.	timestamp() → "2024-11-20T12:00:00Z"

##############################################################################################################
9. Hashing Functions
Compute cryptographic hashes.

Function	Description	Example
md5(string)	Returns the MD5 hash of a string.	md5("hello") → "5d41402abc4b2a76b9719d911017c592"

sha1(string)	Returns the SHA-1 hash of a string.	sha1("hello") → "aaf4c61ddcc5e8a2dabede0f3b482cd9ea9434d"

################################################################################################################
10. Type Conversion Functions
Convert between different types.


tostring(value)	Converts a value to a string.	tostring(123) → "123"

tolist(value)	Converts a value to a list.	tolist([1, 2, 3]) → [1, 2, 3]

tomap(value)	Converts a value to a map.	tomap({a = 1}) → {a = 1}

######################################################################################################################
Using Terraform Functions
Functions can be combined within configurations for dynamic behavior. Example:


variable "subnet_count" {
  default = 3
}

resource "aws_subnet" "example" {
  count       = var.subnet_count
  cidr_block  = cidrsubnet("10.0.0.0/16", 8, count.index)
  vpc_id      = aws_vpc.example.id
  tags = {
    Name = "subnet-${count.index}"
  }
}
This uses cidrsubnet to dynamically create subnets based on the count.


Combine Functions: Use multiple functions together for complex logic.

,", ["a", "b", "c"]), ",", "-")  # Result: "a-b-c"
Avoid Hardcoding: Use functions to calculate or derive values instead of hardcoding.

Validate Output: Test with terraform console to debug function outputs:


terraform console
> join(",", ["a", "b", "c"])
These functions make Terraform configurations more

##############################################################################################################
Providers
Definition: Plugins that interact with APIs of cloud providers or other services (e.g., AWS, Azure, Google Cloud).
Example:

provider "aws" {
  region = "us-east-1"
}
###########################
2. Resources
Definition: The basic building blocks in Terraform representing cloud services (e.g., EC2 instances, S3 buckets).
Example:

resource "aws_instance" "example" {
  ami           = "ami-123456"
  instance_type = "t2.micro"
}

#########################################
3. Variables
Definition: Input parameters for Terraform configurations.
Example:

variable "region" {
  default = "us-east-1"
}
Use variables in your configuration:

provider "aws" {
  region = var.region
}

##########################################
4. Outputs
Definition: Display or export useful information about resources after applying configurations.
Example:

output "instance_id" {
  value = aws_instance.example.id
}

##############################################
5. State
Definition: Tracks the real-world state of your resources to allow incremental updates.
State File: Stored locally (terraform.tfstate) or remotely (e.g., S3).
Commands:
terraform state list: View tracked resources.
terraform state rm: Remove a resource from state.

##################################################
6. Modules
Definition: Reusable units of Terraform code that organize and group resources.
Example: Call a module:

module "network" {
  source = "./modules/network"
}
Remote modules from the registry:

module "eks" {
  source  = "terraform-aws-modules/eks/aws"
  version = "19.0.0"
}

####################################################
7. Data Sources
Definition: Fetch information about existing resources to use in your configuration.
Example:

data "aws_ami" "latest" {
  most_recent = true
  owners      = ["amazon"]
  filters = {
    name = "amzn2-ami-hvm-*"
  }
}

###########################################################
8. Provisioners
Definition: Execute scripts or actions on a resource after creation.
Example:

resource "aws_instance" "example" {
  provisioner "local-exec" {
    command = "echo 'Instance created!'"
  }
}

#######################################################
9. Backends
Definition: Store Terraform state remotely for collaboration (e.g., S3, Terraform Cloud).
Example (S3 backend):

terraform {
  backend "s3" {
    bucket = "my-terraform-state"
    key    = "state.tfstate"
    region = "us-east-1"
  }
}

######################################################
Terraform Workflow
1. Write Configuration
Define resources and their dependencies in .tf files.

2. Initialize
Download provider plugins and set up the environment.


terraform init
3. Plan
Preview changes that Terraform will make.
terraform plan

4. Apply
Execute the changes to provision resources.


terraform apply
5. Destroy
Remove all resources defined in the configuration.
terraform destroy

##############################################
Advanced Concepts
1. Terraform Functions
Perform operations within configurations.
Examples:
String manipulation: join(",", ["a", "b", "c"])
Math: max(5, 10)
Logic: lookup(map("key", "value"), "key", "default")

######################################################
2. Terraform Workspaces
Manage multiple environments (e.g., dev, prod) with the same configuration.
Commands:
terraform workspace new dev
terraform workspace select dev
terraform workspace list

######################################################
3. Lifecycle Rules
Manage the creation, update, and deletion of resources.
Example:

resource "aws_instance" "example" {
  lifecycle {
    create_before_destroy = true
  }
}

########################################################
4. Dynamic Blocks
Generate blocks programmatically.
Example:

resource "aws_security_group" "example" {
  dynamic "ingress" {
    for_each = var.ports
    content {
      from_port   = ingress.value
      to_port     = ingress.value
      protocol    = "tcp"
      cidr_blocks = ["0.0.0.0/0"]
    }
  }
}

###################################################
5. Dependency Management
Terraform automatically manages dependencies between resources using implicit references (e.g., aws_vpc.id).

##########################################################
6. Remote Execution
Use Terraform Cloud or Enterprise for remote runs and collaboration.
Terraform Commands
Command	Description
terraform init	Initialize the configuration.
terraform plan	Preview resource changes.
terraform apply	Apply changes to infrastructure.
terraform destroy	Destroy infrastructure.
terraform fmt	Format configuration files.
terraform validate	Validate the syntax of configuration files.
terraform state	Inspect and modify Terraform state.
terraform output	Display output values.
terraform import	Import existing resources into Terraform.
terraform taint	Mark a resource for recreation.
Best Practices
Use Version Control:
Store .tf files in Git.
Remote State Management:
Use backends for collaboration.
Use Modules:
Modularize and reuse code.
Environment Isolation:
Separate configurations or workspaces for dev, staging, prod.
Apply terraform fmt Regularly:
Ensure consistent formatting.
Pin Provider Versions:
Avoid unexpected changes by locking versions:

terraform {
  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = "~> 5.0"
    }
  }
}
Common Challenges
State Conflicts:
Use remote state with locking to prevent overwrites.
Drift Detection:
Use terraform plan regularly to detect manual changes in resources.
Breaking Changes:
Always review module and provider release notes when upgrading versions.

#############################################################
main.tf file
##################
terraform {
  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = "~> 5.0"
    }
  }
}

# Configure the AWS Provider
provider "aws" {
  region = "us-west-2"
}
provider "aws" {
  alias = "west"
  region     = "us-west-2"
  #access_key = "AKIAW3MEAISABWULLWUG"
  secret_key = "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"
}

resource "aws_vpc" "my_vpc" {
    cidr_block = "10.0.0.0/16"
}
resource "aws_subnet" "my_subnet" {
  vpc_id     = aws_vpc.my_vpc.id
  cidr_block = "10.0.1.0/24"
  availability_zone = "us-west-2a"
}

resource "aws_security_group" "allow_tls" {
  name        = "allow_tls"
  description = "Allow TLS inbound traffic and all outbound traffic"
  vpc_id      = aws_vpc.my_vpc.id

  ingress {
    description = "TLS from VPC"
    from_port   = 443
    to_port     = 443
    protocol    = "tcp"
    cidr_blocks = [aws_vpc.my_vpc.cidr_block]
  }
  egress {
    from_port   = 0
    to_port     = 0
    protocol    = "-1"
    cidr_blocks = ["0.0.0.0/0"]
  }
}

resource "aws_network_interface" "my_nic" {
  subnet_id       = aws_subnet.my_subnet.id
  private_ips     = ["10.0.1.50"]
  security_groups = [aws_security_group.allow_tls.id]
}

resource "aws_instance" "my_instance" {
  ami           = "ami-005e54dee72cc1d00" 
  instance_type = "t2.micro"

  network_interface {
    network_interface_id = aws_network_interface.my_nic.id
    device_index         = 0
  }

  credit_specification {
    cpu_credits = "unlimited"
  }
}

###################################3
terraform.tfstate 
###################

    }
  ],
  "check_results": null
}
{
  "version": 4,
  "terraform_version": "1.5.0",
  "serial": 6,
  "lineage": "56644c67-16e3-b96c-25f2-c3bdb6f8d45e",
  "outputs": {},
  "resources": [
    {
      "mode": "managed",
      "type": "aws_instance",
      "name": "my_instance",
      "provider": "provider[\"registry.terraform.io/hashicorp/aws\"]",
      "instances": [
        {
          "schema_version": 1,
          "attributes": {
            "ami": "ami-005e54dee72cc1d00",
            "arn": "arn:aws:ec2:us-west-2:851725482328:instance/i-0a540ef16ade96733",
            "associate_public_ip_address": false,
            "availability_zone": "us-west-2a",
            "capacity_reservation_specification": [
              {
                "capacity_reservation_preference": "open",
                "capacity_reservation_target": []
              }
            ],
            "cpu_core_count": 1,
            "cpu_options": [
              {
                "amd_sev_snp": "",
                "core_count": 1,
                "threads_per_core": 1
              }
            ],
            "cpu_threads_per_core": 1,
            "credit_specification": [
              {
                "cpu_credits": "unlimited"
              }
            ],
            "disable_api_stop": false,
            "disable_api_termination": false,
            "ebs_block_device": [],
            "ebs_optimized": false,
            "enclave_options": [
              {
                "enabled": false
              }
            ],
            "ephemeral_block_device": [],
            "get_password_data": false,
            "hibernation": false,
            "host_id": "",
            "host_resource_group_arn": null,
            "iam_instance_profile": "",
            "id": "i-0a540ef16ade96733",
            "instance_initiated_shutdown_behavior": "stop",
            "instance_lifecycle": "",
            "instance_market_options": [],
            "instance_state": "running",
            "instance_type": "t2.micro",
            "ipv6_address_count": 0,
            "ipv6_addresses": [],
            "key_name": "",
            "launch_template": [],
            "maintenance_options": [
              {
                "auto_recovery": "default"
              }
            ],
            "metadata_options": [
              {
                "http_endpoint": "enabled",
                "http_protocol_ipv6": "disabled",
                "http_put_response_hop_limit": 1,
                "http_tokens": "optional",
                "instance_metadata_tags": "disabled"
              }
            ],
            "monitoring": false,
            "network_interface": [
              {
                "delete_on_termination": false,
                "device_index": 0,
                "network_card_index": 0,
                "network_interface_id": "eni-00439511f7d52b854"
              }
            ],
            "outpost_arn": "",
            "password_data": "",
            "placement_group": "",
            "placement_partition_number": 0,
            "primary_network_interface_id": "eni-00439511f7d52b854",
            "private_dns": "ip-10-0-1-50.us-west-2.compute.internal",
            "private_dns_name_options": [
              {
                "enable_resource_name_dns_a_record": false,
                "enable_resource_name_dns_aaaa_record": false,
                "hostname_type": "ip-name"
              }
            ],
            "private_ip": "10.0.1.50",
            "public_dns": "",
            "public_ip": "",
            "root_block_device": [
              {
                "delete_on_termination": true,
                "device_name": "/dev/sda1",
                "encrypted": false,
                "iops": 100,
                "kms_key_id": "",
                "tags": {},
                "tags_all": {},
                "throughput": 0,
                "volume_id": "vol-03eeb0fe11431199c",
                "volume_size": 8,
                "volume_type": "gp2"
              }
            ],
            "secondary_private_ips": [],
            "security_groups": [],
            "source_dest_check": true,
            "spot_instance_request_id": "",
            "subnet_id": "subnet-0c5c66612bf9496df",
            "tags": null,
            "tags_all": {},
            "tenancy": "default",
            "timeouts": null,
            "user_data": null,
            "user_data_base64": null,
            "user_data_replace_on_change": false,
            "volume_tags": null,
            "vpc_security_group_ids": [
              "sg-0ec595bf37a90fbda"
            ]
          },
          "sensitive_attributes": [],
          "private": "eyJlMmJmYjczMC1lY2FhLTExZTYtOGY4OC0zNDM2M2JjN2M0YzAiOnsiY3JlYXRlIjo2MDAwMDAwMDAwMDAsImRlbGV0ZSI6MTIwMDAwMDAwMDAwMCwicmVhZCI6OTAwMDAwMDAwMDAwLCJ1cGRhdGUiOjYwMDAwMDAwMDAwMH0sInNjaGVtYV92ZXJzaW9uIjoiMSJ9",
          "dependencies": [
            "aws_network_interface.my_nic",
            "aws_security_group.allow_tls",
            "aws_subnet.my_subnet",
            "aws_vpc.my_vpc"
          ]
        }
      ]
    },
    {
      "mode": "managed",
      "type": "aws_network_interface",
      "name": "my_nic",
      "provider": "provider[\"registry.terraform.io/hashicorp/aws\"]",
      "instances": [
        {
          "schema_version": 0,
          "attributes": {
            "arn": "arn:aws:ec2:us-west-2:851725482328:network-interface/eni-00439511f7d52b854",
            "attachment": [],
            "description": "",
            "id": "eni-00439511f7d52b854",
            "interface_type": "interface",
            "ipv4_prefix_count": 0,
            "ipv4_prefixes": [],
            "ipv6_address_count": 0,
            "ipv6_address_list": [],
            "ipv6_address_list_enabled": false,
            "ipv6_addresses": [],
            "ipv6_prefix_count": 0,
            "ipv6_prefixes": [],
            "mac_address": "06:19:52:08:63:c1",
            "outpost_arn": "",
            "owner_id": "851725482328",
            "private_dns_name": "",
            "private_ip": "10.0.1.50",
            "private_ip_list": [
              "10.0.1.50"
            ],
            "private_ip_list_enabled": false,
            "private_ips": [
              "10.0.1.50"
            ],
            "private_ips_count": 0,
            "security_groups": [
              "sg-0ec595bf37a90fbda"
            ],
            "source_dest_check": true,
            "subnet_id": "subnet-0c5c66612bf9496df",
            "tags": null,
            "tags_all": {}
          },
          "sensitive_attributes": [],
          "private": "bnVsbA==",
          "dependencies": [
            "aws_security_group.allow_tls",
            "aws_subnet.my_subnet",
            "aws_vpc.my_vpc"
          ]
        }
      ]
    },
    {
      "mode": "managed",
      "type": "aws_security_group",
      "name": "allow_tls",
      "provider": "provider[\"registry.terraform.io/hashicorp/aws\"]",
      "instances": [
        {
          "schema_version": 1,
          "attributes": {
            "arn": "arn:aws:ec2:us-west-2:851725482328:security-group/sg-0ec595bf37a90fbda",
            "description": "Allow TLS inbound traffic and all outbound traffic",
            "egress": [
              {
                "cidr_blocks": [
                  "0.0.0.0/0"
                ],
                "description": "",
                "from_port": 0,
                "ipv6_cidr_blocks": [],
                "prefix_list_ids": [],
                "protocol": "-1",
                "security_groups": [],
                "self": false,
                "to_port": 0
              }
            ],
            "id": "sg-0ec595bf37a90fbda",
            "ingress": [
              {
                "cidr_blocks": [
                  "10.0.0.0/16"
                ],
                "description": "TLS from VPC",
                "from_port": 443,
                "ipv6_cidr_blocks": [],
                "prefix_list_ids": [],
                "protocol": "tcp",
                "security_groups": [],
                "self": false,
                "to_port": 443
              }
            ],
            "name": "allow_tls",
            "name_prefix": "",
            "owner_id": "851725482328",
            "revoke_rules_on_delete": false,
            "tags": null,
            "tags_all": {},
            "timeouts": null,
            "vpc_id": "vpc-0596e12b409f8c5f3"
          },
          "sensitive_attributes": [],
          "private": "eyJlMmJmYjczMC1lY2FhLTExZTYtOGY4OC0zNDM2M2JjN2M0YzAiOnsiY3JlYXRlIjo2MDAwMDAwMDAwMDAsImRlbGV0ZSI6OTAwMDAwMDAwMDAwfSwic2NoZW1hX3ZlcnNpb24iOiIxIn0=",
          "dependencies": [
            "aws_vpc.my_vpc"
          ]
        }
      ]
    },
    {
      "mode": "managed",
      "type": "aws_subnet",
      "name": "my_subnet",
      "provider": "provider[\"registry.terraform.io/hashicorp/aws\"]",
      "instances": [
        {
          "schema_version": 1,
          "attributes": {
            "arn": "arn:aws:ec2:us-west-2:851725482328:subnet/subnet-0c5c66612bf9496df",
            "assign_ipv6_address_on_creation": false,
            "availability_zone": "us-west-2a",
            "availability_zone_id": "usw2-az2",
            "cidr_block": "10.0.1.0/24",
            "customer_owned_ipv4_pool": "",
            "enable_dns64": false,
            "enable_lni_at_device_index": 0,
            "enable_resource_name_dns_a_record_on_launch": false,
            "enable_resource_name_dns_aaaa_record_on_launch": false,
            "id": "subnet-0c5c66612bf9496df",
            "ipv6_cidr_block": "",
            "ipv6_cidr_block_association_id": "",
            "ipv6_native": false,
            "map_customer_owned_ip_on_launch": false,
            "map_public_ip_on_launch": false,
            "outpost_arn": "",
            "owner_id": "851725482328",
            "private_dns_hostname_type_on_launch": "ip-name",
            "tags": null,
            "tags_all": {},
            "timeouts": null,
            "vpc_id": "vpc-0596e12b409f8c5f3"
          },
          "sensitive_attributes": [],
          "private": "eyJlMmJmYjczMC1lY2FhLTExZTYtOGY4OC0zNDM2M2JjN2M0YzAiOnsiY3JlYXRlIjo2MDAwMDAwMDAwMDAsImRlbGV0ZSI6MTIwMDAwMDAwMDAwMH0sInNjaGVtYV92ZXJzaW9uIjoiMSJ9",
          "dependencies": [
            "aws_vpc.my_vpc"
          ]
        }
      ]
    },
    {
      "mode": "managed",
      "type": "aws_vpc",
      "name": "my_vpc",
      "provider": "provider[\"registry.terraform.io/hashicorp/aws\"]",
      "instances": [
        {
          "schema_version": 1,
          "attributes": {
            "arn": "arn:aws:ec2:us-west-2:851725482328:vpc/vpc-0596e12b409f8c5f3",
            "assign_generated_ipv6_cidr_block": false,
            "cidr_block": "10.0.0.0/16",
            "default_network_acl_id": "acl-04cd693f6eda975a3",
            "default_route_table_id": "rtb-0d7e11d3a8cddf457",
            "default_security_group_id": "sg-0ecd747e181956f25",
            "dhcp_options_id": "dopt-0d9b83a2c5a8ac141",
            "enable_dns_hostnames": false,
            "enable_dns_support": true,
            "enable_network_address_usage_metrics": false,
            "id": "vpc-0596e12b409f8c5f3",
            "instance_tenancy": "default",
            "ipv4_ipam_pool_id": null,
            "ipv4_netmask_length": null,
            "ipv6_association_id": "",
            "ipv6_cidr_block": "",
            "ipv6_cidr_block_network_border_group": "",
            "ipv6_ipam_pool_id": "",
            "ipv6_netmask_length": 0,
            "main_route_table_id": "rtb-0d7e11d3a8cddf457",
            "owner_id": "851725482328",
            "tags": null,
            "tags_all": {}
          },
          "sensitive_attributes": [],
          "private": "eyJzY2hlbWFfdmVyc2lvbiI6IjEifQ=="
        }
      ]


#####################################################################################
variable.tf ,this file for modules
##################
variable "rgname" {
    type = string
    description = "used for naming resource group"
}

variable "location" {
    type = string 
    description = "used for selecting location"
}

variable "prefix" {
    type = string
    description = "The prefix used for all resources in this example"
}

variable "my_vpc" {
    type = string
    description = "this variable defines vpc"
}

variable "my_subnet" {
    type = string
    description = "defines subnet"
}

#########################################################
modules
dev.tf
###################
terraform {
  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = "~> 5.0"
    }
  }
}


module "module_dev" {
    location = "west-us-2"
    source = "./modules"
    prefix = "dev"
    my_vpc = "10.0.0.0/16"
    my_subnet = "10.0.1.0/24"
    rgname = "DevRG"
    
    
}

##########################3
prod.tf
#################

module "module_prod" {
    location = "west-us-2"
    source = "./modules"
    prefix = "prod"
    rgname = "ProdRG"
     my_vpc = "10.30.0.0/16"
    my_subnet = "10.30.1.0/24"
}

###########################
uat.tf
######################

module "module_uat" {
    location = "west-us-2"
    source = "./modules"
    prefix = "Uat"
    rgname = "UatRG"
    my_vpc = "10.40.0.0/16"
    my_subnet = "10.40.1.0/24"
}

#######################################
Backend or Remote state

terraform {
  backend "s3" {
    bucket = "mybucket"
    key    = "path/to/my/key"
    region = "us-east-1"
  }
}
#########################################
Create S3 bucket

resource "aws_s3_bucket" "example" {
  bucket = "my-tf-test-bucket"

  tags = {
    Name        = "My bucket"
    Environment = "Dev"
  }
}
###############################################
DynamoDB table:

resource "aws_dynamodb_table" "basic-dynamodb-table" {
  name           = "Statelock"
  billing_mode   = "PROVISIONED"
  read_capacity  = 20
  write_capacity = 20
  hash_key       = "UserId"
  range_key      = "GameTitle"

  attribute {
    name = "UserId"
    type = "S"
  }

  attribute {
    name = "GameTitle"
    type = "S"
  }

  attribute {
    name = "TopScore"
    type = "N"
  }

  ttl {
    attribute_name = "TimeToExist"
    enabled        = true
  }

  global_secondary_index {
    name               = "GameTitleIndex"
    hash_key           = "GameTitle"
    range_key          = "TopScore"
    write_capacity     = 10
    read_capacity      = 10
    projection_type    = "INCLUDE"
    non_key_attributes = ["UserId"]
  }

  tags = {
    Name        = "dynamodb-table-1"
    Environment = "production"
  }
}
############################################################
Data sources

data "aws_instance" "foo" {
  instance_id = "i-instanceid"

  filter {
    name   = "image-id"
    values = ["ami-xxxxxxxx"]
  }

  filter {
    name   = "tag:Name"
    values = ["instance-name-tag"]
  }
}
#################################################
LOcals:

locals {
  host        = aws_eks_cluster.example_0.endpoint
  certificate = base64decode(aws_eks_cluster.example_0.certificate_authority.data)
}

provider "helm" {
  kubernetes {
    host                   = local.host
    cluster_ca_certificate = local.certificate
    # exec allows for an authentication command to be run to obtain user
    # credentials rather than having them stored directly in the file
    exec {
      api_version = "client.authentication.k8s.io/v1beta1"
      args        = ["eks", "get-token", "--cluster-name", aws_eks_cluster.example_0.name]
      command     = "aws"
    }
  }
}

######################################################
File Provisioner:
#####
resource "aws_instance" "web" {
  # ...

  # Copies the myapp.conf file to /etc/myapp.conf
  provisioner "file" {
    source      = "conf/myapp.conf"
    destination = "/etc/myapp.conf"
  }

  # Copies the string in content into /tmp/file.log
  provisioner "file" {
    content     = "ami used: ${self.ami}"
    destination = "/tmp/file.log"
  }

  # Copies the configs.d folder to /etc/configs.d
  provisioner "file" {
    source      = "conf/configs.d"
    destination = "/etc"
  }

  # Copies all files and folders in apps/app1 to D:/IIS/webapp1
  provisioner "file" {
    source      = "apps/app1/"
    destination = "D:/IIS/webapp1"
  }
}
#######################################################
Local-exec Provisioner

resource "aws_instance" "web" {
  # ...

  provisioner "local-exec" {
    command = "echo ${self.private_ip} >> private_ips.txt"
  }
}

###############################################################
Remote-exec Provisioner

resource "aws_instance" "web" {
  # ...

  # Establishes connection to be used by all
  # generic remote provisioners (i.e. file/remote-exec)
  connection {
    type     = "ssh"
    user     = "root"
    password = var.root_password
    host     = self.public_ip
  }

  provisioner "remote-exec" {
    inline = [
      "puppet apply",
      "consul join ${aws_instance.web.private_ip}",
    ]
  }
}

##############################################################
Terraform workspaces:

main.tf
dev.tfvars
prod.tfvars
variables.tf

to create new workspace ---->terraform workspace new dev
and switched to dev 

to show workspaces ---> terraform workspace list
same for prod
swiches to another env ----> terraform workspace select dev
then terraform init
terraform apply -var-file dev.tfvars

####################################################################
Terraform with DynamoDB:

resource "aws_dynamodb_table" "project_sapphire_inventory" {
  name           = "inventory"
  billing_mode   = "PAY_PER_REQUEST"
  hash_key       = "AssetID"

  attribute {
    name = "AssetID"
    type = "N"
  }
  attribute {
    name = "AssetName"
    type = "S"
  }
  attribute {
    name = "age"
    type = "N"
  }
  attribute {
    name = "Hardware"
    type = "B"
  }
  global_secondary_index {
    name             = "AssetName"
    hash_key         = "AssetName"
    projection_type    = "ALL"

  }
  global_secondary_index {
    name             = "age"
    hash_key         = "age"
    projection_type    = "ALL"

  }
  global_secondary_index {
    name             = "Hardware"
    hash_key         = "Hardware"
    projection_type    = "ALL"

  }
}
resource "aws_dynamodb_table_item" "upload" {
  table_name = aws_dynamodb_table.project_sapphire_inventory.name
  hash_key   = aws_dynamodb_table.project_sapphire_inventory.hash_key
  item = <<EOF
 {
  "AssetID": {"N": "1"},
  "AssetName": {"S": "printer"},
  "age": {"N": "5"},
  "Hardware": {"B": "true" }
}
EOF
}

##############################################################
Terraform with S3

resource "aws_s3_bucket" "dc_bucket" {
  bucket = "dc_is_better_than_marvel"
  }

resource "aws_s3_object" "upload" {
  bucket = "pixar-studios-2020"
  key    = "woody.jpg"
  source = "/root/woody.jpg"
}
#############################################################
Terraform with IAM

resource "aws_iam_user" "users" {
     name = "mary"
     region = "us-east-1"
}

update the iam-user.tf to make use of the count meta-argument to loop through the project-sapphire-users variable and create all the users in the list.

resource "aws_iam_user" "users" {
     name = var.project-sapphire-users[count.index]
     count = length(var.project-sapphire-users)
}

#######################################################################
Terraform Modules

Terraform modules are reusable blocks of configuration that allow you to define and manage multiple infrastructure resources as a single unit. 
They enable you to break down complex infrastructure deployments into smaller, more manageable pieces, promoting modularity and reusability.


A module for creating a virtual private cloud (VPC) with subnets and security groups
A module for provisioning a database cluster with scaling and backup policies
A module for deploying a load balancer with auto-scaling and SSL termination
By using Terraform modules, you can speed up your infrastructure deployments, reduce errors, and improve maintainability.

What is a Terraform module? A Terraform module is a collection of standard configuration files in a dedicated directory. 
Terraform modules encapsulate groups of resources dedicated to one task,
reducing the amount of code you have to develop for similar infrastructure components.

module "iam_iam-user" {
  source  = "terraform-aws-modules/iam/aws//modules/iam-user"
  version = "5.28.0"
  # insert the 1 required variable here
  name = "sai"
}

#######################################################################
Using Provisioners:

terraform {
  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = "~> 5.0"
    }
  }
}

# Configure the AWS Provider
provider "aws" {
  region = "us-west-2"
}
provider "aws" {
  alias = "west"
  region     = "us-west-2"
  #access_key = "AKIAW3MEAISABWULLWUG"
  secret_key = "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"
}

resource "aws_vpc" "my_vpc" {
    cidr_block = "10.0.0.0/16"
}
resource "aws_subnet" "my_subnet" {
  vpc_id     = aws_vpc.my_vpc.id
  cidr_block = "10.0.1.0/24"
  availability_zone = "us-west-2a"
}

resource "aws_security_group" "allow_tls" {
  name        = "allow_tls"
  description = "Allow TLS inbound traffic and all outbound traffic"
  vpc_id      = aws_vpc.my_vpc.id

  ingress {
    description = "TLS from VPC"
    from_port   = 443
    to_port     = 443
    protocol    = "tcp"
    cidr_blocks = [aws_vpc.my_vpc.cidr_block]
  }
  egress {
    from_port   = 0
    to_port     = 0
    protocol    = "-1"
    cidr_blocks = ["0.0.0.0/0"]
  }
}

resource "aws_network_interface" "my_nic" {
  subnet_id       = aws_subnet.my_subnet.id
  private_ips     = ["10.0.1.50"]
  security_groups = [aws_security_group.allow_tls.id]
}

resource "aws_instance" "my_instance" {
  ami           = "ami-005e54dee72cc1d00" 
  instance_type = "t2.micro"

  tags = {
    name = "sai_instance"
  }

  provisioner "local-exec" {
    command =  "echo 'subnetID: ${self.subnet_id}'  >> subnetInfo.txt"
    
  }

  network_interface {
    network_interface_id = aws_network_interface.my_nic.id
    device_index         = 0
  }

  credit_specification {
    cpu_credits = "unlimited"
  }
}

########################################################

Create aws EKS by using Terraform 
####################################
main.tf

terraform {
  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = "~> 5.0"
    }
  }
}

# Configure the AWS Provider
provider "aws" {
  region = "us-east-1"
}

resource "aws_eks_cluster" "example" {
  name     = "example"
  role_arn = aws_iam_role.eksClusterRole.arn

  vpc_config {
    subnet_ids = ["subnet-0db93f133f15daf79", "subnet-0874af9b0c91fa50a"]
  } 

  # Ensure that IAM Role permissions are created before and deleted after EKS Cluster handling.
  # Otherwise, EKS will not be able to properly delete EKS managed EC2 infrastructure such as Security Groups.
  depends_on = [
    aws_iam_role_policy_attachment.example-AmazonEKSClusterPolicy,
    aws_iam_role_policy_attachment.example-AmazonEKSVPCResourceController,
  ]
}

output "endpoint" {
  value = aws_eks_cluster.example.endpoint
}

output "kubeconfig-certificate-authority-data" {
  value = aws_eks_cluster.example.certificate_authority[0].data
}

data "aws_iam_policy_document" "assume_role" {
  statement {
    effect = "Allow"

    principals {
      type        = "Service"
      identifiers = ["eks.amazonaws.com"]
    }

    actions = ["sts:AssumeRole"]
  }
}

resource "aws_iam_role" "eksClusterRole" {
  name               = "eksClusterRole"
  assume_role_policy = data.aws_iam_policy_document.assume_role.json
}

resource "aws_iam_role_policy_attachment" "example-AmazonEKSClusterPolicy" {
  policy_arn = "arn:aws:iam::aws:policy/AmazonEKSClusterPolicy"
  role       = aws_iam_role.eksClusterRole.name
}

# Optionally, enable Security Groups for Pods
# Reference: https://docs.aws.amazon.com/eks/latest/userguide/security-groups-for-pods.html
resource "aws_iam_role_policy_attachment" "example-AmazonEKSVPCResourceController" {
  policy_arn = "arn:aws:iam::aws:policy/AmazonEKSVPCResourceController"
  role       = aws_iam_role.eksClusterRole.name
}



#To install KUbectl to access EKS

provider "null" {}

resource "null_resource" "install_kubectl" {
  provisioner "local-exec" {
    command = <<EOT
    # Define the current working directory
    WORKING_DIR=$(pwd)

    # Download the latest kubectl binary to the working directory
    curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"

    # Make it executable
    chmod +x kubectl

    # Move it to the current working directory
    mv kubectl $WORKING_DIR

    # Verify the installation
    ./kubectl version --client
    EOT
  }
}

#Then apply commands
#terraform init 
#terraform apply

#Then  we should update kubeconfig by
aws eks --region us-east-1 update-kubeconfig --name example
#cat /etc/*release to check OS

#if AWS CLI is not installed we should instal aws cli

provider "null" {}

resource "null_resource" "install_aws_cli" {
  provisioner "local-exec" {
    command = <<EOT
    # Define the working directory (optional, typically /tmp or current dir)
    WORKING_DIR=$(pwd)

    # Download the AWS CLI installer (version 2)
    curl "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" -o "awscliv2.zip"

    # Unzip the installer
    unzip awscliv2.zip -d $WORKING_DIR

    # Run the installer
    sudo $WORKING_DIR/aws/install

    # Verify the installation
    aws --version
    EOT
  }
}

output "aws_cli_installation_status" {
  value = "AWS CLI installed successfully"
}



############################################################################

terraform init

Initializes a Terraform working directory.
Downloads provider plugins and sets up the backend configuration.
Run this command first when starting a project.

terraform init
terraform validate

Validates the configuration files for syntax and structural correctness.
Does not interact with infrastructure or state.

terraform validate
terraform plan

Creates an execution plan, showing the changes Terraform will make to your infrastructure.
A safe "dry-run" to review before applying changes.

terraform plan
terraform apply

Applies the changes required to reach the desired state of your configuration.
Prompts for confirmation unless a saved plan file is provided.

terraform apply
terraform destroy

Destroys all resources defined in the configuration.
Useful for cleaning up after testing or decommissioning infrastructure.

This generates a plan where the ex,aws_instance.web resource is marked for destruction and recreation.
terraform plan -replace="resource_type.resource_name

terraform destroy
terraform show

Displays details of the current state or a saved execution plan.

terraform show
terraform output

Extracts and displays values from the output section of your configuration.

terraform output
terraform fmt

Formats Terraform configuration files to follow the standardized style.

terraform fmt
terraform state

Manages the Terraform state file, enabling actions like moving, removing, or importing resources.
Example:


terraform state list   # Lists all resources in the state
terraform state mv     # Moves resources within the state
terraform import

Brings an existing resource into Terraform management by adding it to the state file.

terraform import <resource_name> <real_world_identifier>
terraform refresh

Updates the state file to match the real-world infrastructure without modifying resources.

terraform refresh
terraform workspace

Manages workspaces (isolated state files) for managing multiple environments like dev, test, prod.

terraform workspace list   # List workspaces
terraform workspace new    # Create a new workspace
terraform taint (Deprecated, use terraform apply -replace instead)
Marks a resource for recreation during the next terraform apply.
terraform untaint

Removes the taint marking from a resource, so it won’t be recreated.

terraform untaint <resource_name>
terraform graph

Generates a visual graph of the Terraform resources and their dependencies.
bash
Copy code
terraform graph | dot -Tsvg > graph.svg
terraform login

Authenticates with Terraform Cloud or a private Terraform Enterprise instance.

terraform login
Initialization & Setup: terraform init
Validation: terraform validate
Preview Changes: terraform plan
Apply Changes: terraform apply
Destroy Resources: terraform destroy
Manage State: terraform state
Import Resources: terraform import
Output Management: terraform output
Formatting: terraform fmt
Providers
Definition: Plugins that interact with APIs of cloud providers or other services (e.g., AWS, Azure, Google Cloud).
Example:

provider "aws" {
  region = "us-east-1"
}
###########################
2. Resources
Definition: The basic building blocks in Terraform representing cloud services (e.g., EC2 instances, S3 buckets).
Example:

resource "aws_instance" "example" {
  ami           = "ami-123456"
  instance_type = "t2.micro"
}

#########################################
3. Variables
Definition: Input parameters for Terraform configurations.
Example:

variable "region" {
  default = "us-east-1"
}
Use variables in your configuration:

provider "aws" {
  region = var.region
}

##########################################
4. Outputs
Definition: Display or export useful information about resources after applying configurations.
Example:

output "instance_id" {
  value = aws_instance.example.id
}

##############################################
5. State
Definition: Tracks the real-world state of your resources to allow incremental updates.
State File: Stored locally (terraform.tfstate) or remotely (e.g., S3).
Commands:
terraform state list: View tracked resources.
terraform state rm: Remove a resource from state.

##################################################
6. Modules
Definition: Reusable units of Terraform code that organize and group resources.
Example: Call a module:

module "network" {
  source = "./modules/network"
}
Remote modules from the registry:

module "eks" {
  source  = "terraform-aws-modules/eks/aws"
  version = "19.0.0"
}

####################################################
7. Data Sources
Definition: Fetch information about existing resources to use in your configuration.
Example:

data "aws_ami" "latest" {
  most_recent = true
  owners      = ["amazon"]
  filters = {
    name = "amzn2-ami-hvm-*"
  }
}

###########################################################
8. Provisioners
Definition: Execute scripts or actions on a resource after creation.
Example:

resource "aws_instance" "example" {
  provisioner "local-exec" {
    command = "echo 'Instance created!'"
  }
}

#######################################################
9. Backends
Definition: Store Terraform state remotely for collaboration (e.g., S3, Terraform Cloud).
Example (S3 backend):

terraform {
  backend "s3" {
    bucket = "my-terraform-state"
    key    = "state.tfstate"
    region = "us-east-1"
  }
}

######################################################
Terraform Workflow
1. Write Configuration
Define resources and their dependencies in .tf files.

2. Initialize
Download provider plugins and set up the environment.


terraform init
3. Plan
Preview changes that Terraform will make.
terraform plan

4. Apply
Execute the changes to provision resources.


terraform apply
5. Destroy
Remove all resources defined in the configuration.
terraform destroy

##############################################
Advanced Concepts
1. Terraform Functions
Perform operations within configurations.
Examples:
String manipulation: join(",", ["a", "b", "c"])
Math: max(5, 10)
Logic: lookup(map("key", "value"), "key", "default")

######################################################
2. Terraform Workspaces
Manage multiple environments (e.g., dev, prod) with the same configuration.
Commands:
terraform workspace new dev
terraform workspace select dev
terraform workspace list

######################################################
3. Lifecycle Rules
Manage the creation, update, and deletion of resources.
Example:

resource "aws_instance" "example" {
  lifecycle {
    create_before_destroy = true
  }
}

########################################################
4. Dynamic Blocks
Generate blocks programmatically.
Example:

resource "aws_security_group" "example" {
  dynamic "ingress" {
    for_each = var.ports
    content {
      from_port   = ingress.value
      to_port     = ingress.value
      protocol    = "tcp"
      cidr_blocks = ["0.0.0.0/0"]
    }
  }
}

###################################################
5. Dependency Management
Terraform automatically manages dependencies between resources using implicit references (e.g., aws_vpc.id).

##########################################################
6. Remote Execution
Use Terraform Cloud or Enterprise for remote runs and collaboration.
Terraform Commands
Command	Description
terraform init	Initialize the configuration.
terraform plan	Preview resource changes.
terraform apply	Apply changes to infrastructure.
terraform destroy	Destroy infrastructure.
terraform fmt	Format configuration files.
terraform validate	Validate the syntax of configuration files.
terraform state	Inspect and modify Terraform state.
terraform output	Display output values.
terraform import	Import existing resources into Terraform.
terraform taint	Mark a resource for recreation.
Best Practices
Use Version Control:
Store .tf files in Git.
Remote State Management:
Use backends for collaboration.
Use Modules:
Modularize and reuse code.
Environment Isolation:
Separate configurations or workspaces for dev, staging, prod.
Apply terraform fmt Regularly:
Ensure consistent formatting.
Pin Provider Versions:
Avoid unexpected changes by locking versions:

terraform {
  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = "~> 5.0"
    }
  }
}
Common Challenges
State Conflicts:
Use remote state with locking to prevent overwrites.
Drift Detection:
Use terraform plan regularly to detect manual changes in resources.
Breaking Changes:
Always review module and provider release notes when upgrading versions.

#############################################################
main.tf file
##################
terraform {
  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = "~> 5.0"
    }
  }
}

# Configure the AWS Provider
provider "aws" {
  region = "us-west-2"
}
provider "aws" {
  alias = "west"
  region     = "us-west-2"
  #access_key = "AKIAW3MEAISABWULLWUG"
  secret_key = "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"
}

resource "aws_vpc" "my_vpc" {
    cidr_block = "10.0.0.0/16"
}
resource "aws_subnet" "my_subnet" {
  vpc_id     = aws_vpc.my_vpc.id
  cidr_block = "10.0.1.0/24"
  availability_zone = "us-west-2a"
}

resource "aws_security_group" "allow_tls" {
  name        = "allow_tls"
  description = "Allow TLS inbound traffic and all outbound traffic"
  vpc_id      = aws_vpc.my_vpc.id

  ingress {
    description = "TLS from VPC"
    from_port   = 443
    to_port     = 443
    protocol    = "tcp"
    cidr_blocks = [aws_vpc.my_vpc.cidr_block]
  }
  egress {
    from_port   = 0
    to_port     = 0
    protocol    = "-1"
    cidr_blocks = ["0.0.0.0/0"]
  }
}

resource "aws_network_interface" "my_nic" {
  subnet_id       = aws_subnet.my_subnet.id
  private_ips     = ["10.0.1.50"]
  security_groups = [aws_security_group.allow_tls.id]
}

resource "aws_instance" "my_instance" {
  ami           = "ami-005e54dee72cc1d00" 
  instance_type = "t2.micro"

  network_interface {
    network_interface_id = aws_network_interface.my_nic.id
    device_index         = 0
  }

  credit_specification {
    cpu_credits = "unlimited"
  }
}

###################################3
terraform.tfstate 
###################

    }
  ],
  "check_results": null
}
{
  "version": 4,
  "terraform_version": "1.5.0",
  "serial": 6,
  "lineage": "56644c67-16e3-b96c-25f2-c3bdb6f8d45e",
  "outputs": {},
  "resources": [
    {
      "mode": "managed",
      "type": "aws_instance",
      "name": "my_instance",
      "provider": "provider[\"registry.terraform.io/hashicorp/aws\"]",
      "instances": [
        {
          "schema_version": 1,
          "attributes": {
            "ami": "ami-005e54dee72cc1d00",
            "arn": "arn:aws:ec2:us-west-2:851725482328:instance/i-0a540ef16ade96733",
            "associate_public_ip_address": false,
            "availability_zone": "us-west-2a",
            "capacity_reservation_specification": [
              {
                "capacity_reservation_preference": "open",
                "capacity_reservation_target": []
              }
            ],
            "cpu_core_count": 1,
            "cpu_options": [
              {
                "amd_sev_snp": "",
                "core_count": 1,
                "threads_per_core": 1
              }
            ],
            "cpu_threads_per_core": 1,
            "credit_specification": [
              {
                "cpu_credits": "unlimited"
              }
            ],
            "disable_api_stop": false,
            "disable_api_termination": false,
            "ebs_block_device": [],
            "ebs_optimized": false,
            "enclave_options": [
              {
                "enabled": false
              }
            ],
            "ephemeral_block_device": [],
            "get_password_data": false,
            "hibernation": false,
            "host_id": "",
            "host_resource_group_arn": null,
            "iam_instance_profile": "",
            "id": "i-0a540ef16ade96733",
            "instance_initiated_shutdown_behavior": "stop",
            "instance_lifecycle": "",
            "instance_market_options": [],
            "instance_state": "running",
            "instance_type": "t2.micro",
            "ipv6_address_count": 0,
            "ipv6_addresses": [],
            "key_name": "",
            "launch_template": [],
            "maintenance_options": [
              {
                "auto_recovery": "default"
              }
            ],
            "metadata_options": [
              {
                "http_endpoint": "enabled",
                "http_protocol_ipv6": "disabled",
                "http_put_response_hop_limit": 1,
                "http_tokens": "optional",
                "instance_metadata_tags": "disabled"
              }
            ],
            "monitoring": false,
            "network_interface": [
              {
                "delete_on_termination": false,
                "device_index": 0,
                "network_card_index": 0,
                "network_interface_id": "eni-00439511f7d52b854"
              }
            ],
            "outpost_arn": "",
            "password_data": "",
            "placement_group": "",
            "placement_partition_number": 0,
            "primary_network_interface_id": "eni-00439511f7d52b854",
            "private_dns": "ip-10-0-1-50.us-west-2.compute.internal",
            "private_dns_name_options": [
              {
                "enable_resource_name_dns_a_record": false,
                "enable_resource_name_dns_aaaa_record": false,
                "hostname_type": "ip-name"
              }
            ],
            "private_ip": "10.0.1.50",
            "public_dns": "",
            "public_ip": "",
            "root_block_device": [
              {
                "delete_on_termination": true,
                "device_name": "/dev/sda1",
                "encrypted": false,
                "iops": 100,
                "kms_key_id": "",
                "tags": {},
                "tags_all": {},
                "throughput": 0,
                "volume_id": "vol-03eeb0fe11431199c",
                "volume_size": 8,
                "volume_type": "gp2"
              }
            ],
            "secondary_private_ips": [],
            "security_groups": [],
            "source_dest_check": true,
            "spot_instance_request_id": "",
            "subnet_id": "subnet-0c5c66612bf9496df",
            "tags": null,
            "tags_all": {},
            "tenancy": "default",
            "timeouts": null,
            "user_data": null,
            "user_data_base64": null,
            "user_data_replace_on_change": false,
            "volume_tags": null,
            "vpc_security_group_ids": [
              "sg-0ec595bf37a90fbda"
            ]
          },
          "sensitive_attributes": [],
          "private": "eyJlMmJmYjczMC1lY2FhLTExZTYtOGY4OC0zNDM2M2JjN2M0YzAiOnsiY3JlYXRlIjo2MDAwMDAwMDAwMDAsImRlbGV0ZSI6MTIwMDAwMDAwMDAwMCwicmVhZCI6OTAwMDAwMDAwMDAwLCJ1cGRhdGUiOjYwMDAwMDAwMDAwMH0sInNjaGVtYV92ZXJzaW9uIjoiMSJ9",
          "dependencies": [
            "aws_network_interface.my_nic",
            "aws_security_group.allow_tls",
            "aws_subnet.my_subnet",
            "aws_vpc.my_vpc"
          ]
        }
      ]
    },
    {
      "mode": "managed",
      "type": "aws_network_interface",
      "name": "my_nic",
      "provider": "provider[\"registry.terraform.io/hashicorp/aws\"]",
      "instances": [
        {
          "schema_version": 0,
          "attributes": {
            "arn": "arn:aws:ec2:us-west-2:851725482328:network-interface/eni-00439511f7d52b854",
            "attachment": [],
            "description": "",
            "id": "eni-00439511f7d52b854",
            "interface_type": "interface",
            "ipv4_prefix_count": 0,
            "ipv4_prefixes": [],
            "ipv6_address_count": 0,
            "ipv6_address_list": [],
            "ipv6_address_list_enabled": false,
            "ipv6_addresses": [],
            "ipv6_prefix_count": 0,
            "ipv6_prefixes": [],
            "mac_address": "06:19:52:08:63:c1",
            "outpost_arn": "",
            "owner_id": "851725482328",
            "private_dns_name": "",
            "private_ip": "10.0.1.50",
            "private_ip_list": [
              "10.0.1.50"
            ],
            "private_ip_list_enabled": false,
            "private_ips": [
              "10.0.1.50"
            ],
            "private_ips_count": 0,
            "security_groups": [
              "sg-0ec595bf37a90fbda"
            ],
            "source_dest_check": true,
            "subnet_id": "subnet-0c5c66612bf9496df",
            "tags": null,
            "tags_all": {}
          },
          "sensitive_attributes": [],
          "private": "bnVsbA==",
          "dependencies": [
            "aws_security_group.allow_tls",
            "aws_subnet.my_subnet",
            "aws_vpc.my_vpc"
          ]
        }
      ]
    },
    {
      "mode": "managed",
      "type": "aws_security_group",
      "name": "allow_tls",
      "provider": "provider[\"registry.terraform.io/hashicorp/aws\"]",
      "instances": [
        {
          "schema_version": 1,
          "attributes": {
            "arn": "arn:aws:ec2:us-west-2:851725482328:security-group/sg-0ec595bf37a90fbda",
            "description": "Allow TLS inbound traffic and all outbound traffic",
            "egress": [
              {
                "cidr_blocks": [
                  "0.0.0.0/0"
                ],
                "description": "",
                "from_port": 0,
                "ipv6_cidr_blocks": [],
                "prefix_list_ids": [],
                "protocol": "-1",
                "security_groups": [],
                "self": false,
                "to_port": 0
              }
            ],
            "id": "sg-0ec595bf37a90fbda",
            "ingress": [
              {
                "cidr_blocks": [
                  "10.0.0.0/16"
                ],
                "description": "TLS from VPC",
                "from_port": 443,
                "ipv6_cidr_blocks": [],
                "prefix_list_ids": [],
                "protocol": "tcp",
                "security_groups": [],
                "self": false,
                "to_port": 443
              }
            ],
            "name": "allow_tls",
            "name_prefix": "",
            "owner_id": "851725482328",
            "revoke_rules_on_delete": false,
            "tags": null,
            "tags_all": {},
            "timeouts": null,
            "vpc_id": "vpc-0596e12b409f8c5f3"
          },
          "sensitive_attributes": [],
          "private": "eyJlMmJmYjczMC1lY2FhLTExZTYtOGY4OC0zNDM2M2JjN2M0YzAiOnsiY3JlYXRlIjo2MDAwMDAwMDAwMDAsImRlbGV0ZSI6OTAwMDAwMDAwMDAwfSwic2NoZW1hX3ZlcnNpb24iOiIxIn0=",
          "dependencies": [
            "aws_vpc.my_vpc"
          ]
        }
      ]
    },
    {
      "mode": "managed",
      "type": "aws_subnet",
      "name": "my_subnet",
      "provider": "provider[\"registry.terraform.io/hashicorp/aws\"]",
      "instances": [
        {
          "schema_version": 1,
          "attributes": {
            "arn": "arn:aws:ec2:us-west-2:851725482328:subnet/subnet-0c5c66612bf9496df",
            "assign_ipv6_address_on_creation": false,
            "availability_zone": "us-west-2a",
            "availability_zone_id": "usw2-az2",
            "cidr_block": "10.0.1.0/24",
            "customer_owned_ipv4_pool": "",
            "enable_dns64": false,
            "enable_lni_at_device_index": 0,
            "enable_resource_name_dns_a_record_on_launch": false,
            "enable_resource_name_dns_aaaa_record_on_launch": false,
            "id": "subnet-0c5c66612bf9496df",
            "ipv6_cidr_block": "",
            "ipv6_cidr_block_association_id": "",
            "ipv6_native": false,
            "map_customer_owned_ip_on_launch": false,
            "map_public_ip_on_launch": false,
            "outpost_arn": "",
            "owner_id": "851725482328",
            "private_dns_hostname_type_on_launch": "ip-name",
            "tags": null,
            "tags_all": {},
            "timeouts": null,
            "vpc_id": "vpc-0596e12b409f8c5f3"
          },
          "sensitive_attributes": [],
          "private": "eyJlMmJmYjczMC1lY2FhLTExZTYtOGY4OC0zNDM2M2JjN2M0YzAiOnsiY3JlYXRlIjo2MDAwMDAwMDAwMDAsImRlbGV0ZSI6MTIwMDAwMDAwMDAwMH0sInNjaGVtYV92ZXJzaW9uIjoiMSJ9",
          "dependencies": [
            "aws_vpc.my_vpc"
          ]
        }
      ]
    },
    {
      "mode": "managed",
      "type": "aws_vpc",
      "name": "my_vpc",
      "provider": "provider[\"registry.terraform.io/hashicorp/aws\"]",
      "instances": [
        {
          "schema_version": 1,
          "attributes": {
            "arn": "arn:aws:ec2:us-west-2:851725482328:vpc/vpc-0596e12b409f8c5f3",
            "assign_generated_ipv6_cidr_block": false,
            "cidr_block": "10.0.0.0/16",
            "default_network_acl_id": "acl-04cd693f6eda975a3",
            "default_route_table_id": "rtb-0d7e11d3a8cddf457",
            "default_security_group_id": "sg-0ecd747e181956f25",
            "dhcp_options_id": "dopt-0d9b83a2c5a8ac141",
            "enable_dns_hostnames": false,
            "enable_dns_support": true,
            "enable_network_address_usage_metrics": false,
            "id": "vpc-0596e12b409f8c5f3",
            "instance_tenancy": "default",
            "ipv4_ipam_pool_id": null,
            "ipv4_netmask_length": null,
            "ipv6_association_id": "",
            "ipv6_cidr_block": "",
            "ipv6_cidr_block_network_border_group": "",
            "ipv6_ipam_pool_id": "",
            "ipv6_netmask_length": 0,
            "main_route_table_id": "rtb-0d7e11d3a8cddf457",
            "owner_id": "851725482328",
            "tags": null,
            "tags_all": {}
          },
          "sensitive_attributes": [],
          "private": "eyJzY2hlbWFfdmVyc2lvbiI6IjEifQ=="
        }
      ]


#####################################################################################
variable.tf ,this file for modules
##################
variable "rgname" {
    type = string
    description = "used for naming resource group"
}

variable "location" {
    type = string 
    description = "used for selecting location"
}

variable "prefix" {
    type = string
    description = "The prefix used for all resources in this example"
}

variable "my_vpc" {
    type = string
    description = "this variable defines vpc"
}

variable "my_subnet" {
    type = string
    description = "defines subnet"
}

#########################################################
modules
dev.tf
###################
terraform {
  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = "~> 5.0"
    }
  }
}


module "module_dev" {
    location = "west-us-2"
    source = "./modules"
    prefix = "dev"
    my_vpc = "10.0.0.0/16"
    my_subnet = "10.0.1.0/24"
    rgname = "DevRG"
    
    
}

##########################3
prod.tf
#################

module "module_prod" {
    location = "west-us-2"
    source = "./modules"
    prefix = "prod"
    rgname = "ProdRG"
     my_vpc = "10.30.0.0/16"
    my_subnet = "10.30.1.0/24"
}

###########################
uat.tf
######################

module "module_uat" {
    location = "west-us-2"
    source = "./modules"
    prefix = "Uat"
    rgname = "UatRG"
    my_vpc = "10.40.0.0/16"
    my_subnet = "10.40.1.0/24"
}

#######################################
Backend or Remote state

terraform {
  backend "s3" {
    bucket = "mybucket"
    key    = "path/to/my/key"
    region = "us-east-1"
  }
}
#########################################
Create S3 bucket

resource "aws_s3_bucket" "example" {
  bucket = "my-tf-test-bucket"

  tags = {
    Name        = "My bucket"
    Environment = "Dev"
  }
}
###############################################
DynamoDB table:

resource "aws_dynamodb_table" "basic-dynamodb-table" {
  name           = "Statelock"
  billing_mode   = "PROVISIONED"
  read_capacity  = 20
  write_capacity = 20
  hash_key       = "UserId"
  range_key      = "GameTitle"

  attribute {
    name = "UserId"
    type = "S"
  }

  attribute {
    name = "GameTitle"
    type = "S"
  }

  attribute {
    name = "TopScore"
    type = "N"
  }

  ttl {
    attribute_name = "TimeToExist"
    enabled        = true
  }

  global_secondary_index {
    name               = "GameTitleIndex"
    hash_key           = "GameTitle"
    range_key          = "TopScore"
    write_capacity     = 10
    read_capacity      = 10
    projection_type    = "INCLUDE"
    non_key_attributes = ["UserId"]
  }

  tags = {
    Name        = "dynamodb-table-1"
    Environment = "production"
  }
}
############################################################
Data sources

data "aws_instance" "foo" {
  instance_id = "i-instanceid"

  filter {
    name   = "image-id"
    values = ["ami-xxxxxxxx"]
  }

  filter {
    name   = "tag:Name"
    values = ["instance-name-tag"]
  }
}
#################################################
LOcals:

locals {
  host        = aws_eks_cluster.example_0.endpoint
  certificate = base64decode(aws_eks_cluster.example_0.certificate_authority.data)
}

provider "helm" {
  kubernetes {
    host                   = local.host
    cluster_ca_certificate = local.certificate
    # exec allows for an authentication command to be run to obtain user
    # credentials rather than having them stored directly in the file
    exec {
      api_version = "client.authentication.k8s.io/v1beta1"
      args        = ["eks", "get-token", "--cluster-name", aws_eks_cluster.example_0.name]
      command     = "aws"
    }
  }
}

######################################################
File Provisioner:
#####
resource "aws_instance" "web" {
  # ...

  # Copies the myapp.conf file to /etc/myapp.conf
  provisioner "file" {
    source      = "conf/myapp.conf"
    destination = "/etc/myapp.conf"
  }

  # Copies the string in content into /tmp/file.log
  provisioner "file" {
    content     = "ami used: ${self.ami}"
    destination = "/tmp/file.log"
  }

  # Copies the configs.d folder to /etc/configs.d
  provisioner "file" {
    source      = "conf/configs.d"
    destination = "/etc"
  }

  # Copies all files and folders in apps/app1 to D:/IIS/webapp1
  provisioner "file" {
    source      = "apps/app1/"
    destination = "D:/IIS/webapp1"
  }
}
#######################################################
Local-exec Provisioner

resource "aws_instance" "web" {
  # ...

  provisioner "local-exec" {
    command = "echo ${self.private_ip} >> private_ips.txt"
  }
}

###############################################################
Remote-exec Provisioner

resource "aws_instance" "web" {
  # ...

  # Establishes connection to be used by all
  # generic remote provisioners (i.e. file/remote-exec)
  connection {
    type     = "ssh"
    user     = "root"
    password = var.root_password
    host     = self.public_ip
  }

  provisioner "remote-exec" {
    inline = [
      "puppet apply",
      "consul join ${aws_instance.web.private_ip}",
    ]
  }
}

##############################################################
Terraform workspaces:

main.tf
dev.tfvars
prod.tfvars
variables.tf

to create new workspace ---->terraform workspace new dev
and switched to dev 

to show workspaces ---> terraform workspace list
same for prod
swiches to another env ----> terraform workspace select dev
then terraform init
terraform apply -var-file dev.tfvars

####################################################################
Terraform with DynamoDB:

resource "aws_dynamodb_table" "project_sapphire_inventory" {
  name           = "inventory"
  billing_mode   = "PAY_PER_REQUEST"
  hash_key       = "AssetID"

  attribute {
    name = "AssetID"
    type = "N"
  }
  attribute {
    name = "AssetName"
    type = "S"
  }
  attribute {
    name = "age"
    type = "N"
  }
  attribute {
    name = "Hardware"
    type = "B"
  }
  global_secondary_index {
    name             = "AssetName"
    hash_key         = "AssetName"
    projection_type    = "ALL"

  }
  global_secondary_index {
    name             = "age"
    hash_key         = "age"
    projection_type    = "ALL"

  }
  global_secondary_index {
    name             = "Hardware"
    hash_key         = "Hardware"
    projection_type    = "ALL"

  }
}
resource "aws_dynamodb_table_item" "upload" {
  table_name = aws_dynamodb_table.project_sapphire_inventory.name
  hash_key   = aws_dynamodb_table.project_sapphire_inventory.hash_key
  item = <<EOF
 {
  "AssetID": {"N": "1"},
  "AssetName": {"S": "printer"},
  "age": {"N": "5"},
  "Hardware": {"B": "true" }
}
EOF
}

##############################################################
Terraform with S3

resource "aws_s3_bucket" "dc_bucket" {
  bucket = "dc_is_better_than_marvel"
  }

resource "aws_s3_object" "upload" {
  bucket = "pixar-studios-2020"
  key    = "woody.jpg"
  source = "/root/woody.jpg"
}
#############################################################
Terraform with IAM

resource "aws_iam_user" "users" {
     name = "mary"
     region = "us-east-1"
}

update the iam-user.tf to make use of the count meta-argument to loop through the project-sapphire-users variable and create all the users in the list.

resource "aws_iam_user" "users" {
     name = var.project-sapphire-users[count.index]
     count = length(var.project-sapphire-users)
}

#######################################################################
Terraform Modules

Terraform modules are reusable blocks of configuration that allow you to define and manage multiple infrastructure resources as a single unit. 
They enable you to break down complex infrastructure deployments into smaller, more manageable pieces, promoting modularity and reusability.


A module for creating a virtual private cloud (VPC) with subnets and security groups
A module for provisioning a database cluster with scaling and backup policies
A module for deploying a load balancer with auto-scaling and SSL termination
By using Terraform modules, you can speed up your infrastructure deployments, reduce errors, and improve maintainability.

What is a Terraform module? A Terraform module is a collection of standard configuration files in a dedicated directory. 
Terraform modules encapsulate groups of resources dedicated to one task,
reducing the amount of code you have to develop for similar infrastructure components.

module "iam_iam-user" {
  source  = "terraform-aws-modules/iam/aws//modules/iam-user"
  version = "5.28.0"
  # insert the 1 required variable here
  name = "sai"
}

#######################################################################
Using Provisioners:

terraform {
  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = "~> 5.0"
    }
  }
}

# Configure the AWS Provider
provider "aws" {
  region = "us-west-2"
}
provider "aws" {
  alias = "west"
  region     = "us-west-2"
  #access_key = "AKIAW3MEAISABWULLWUG"
  secret_key = "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"
}

resource "aws_vpc" "my_vpc" {
    cidr_block = "10.0.0.0/16"
}
resource "aws_subnet" "my_subnet" {
  vpc_id     = aws_vpc.my_vpc.id
  cidr_block = "10.0.1.0/24"
  availability_zone = "us-west-2a"
}

resource "aws_security_group" "allow_tls" {
  name        = "allow_tls"
  description = "Allow TLS inbound traffic and all outbound traffic"
  vpc_id      = aws_vpc.my_vpc.id

  ingress {
    description = "TLS from VPC"
    from_port   = 443
    to_port     = 443
    protocol    = "tcp"
    cidr_blocks = [aws_vpc.my_vpc.cidr_block]
  }
  egress {
    from_port   = 0
    to_port     = 0
    protocol    = "-1"
    cidr_blocks = ["0.0.0.0/0"]
  }
}

resource "aws_network_interface" "my_nic" {
  subnet_id       = aws_subnet.my_subnet.id
  private_ips     = ["10.0.1.50"]
  security_groups = [aws_security_group.allow_tls.id]
}

resource "aws_instance" "my_instance" {
  ami           = "ami-005e54dee72cc1d00" 
  instance_type = "t2.micro"

  tags = {
    name = "sai_instance"
  }

  provisioner "local-exec" {
    command =  "echo 'subnetID: ${self.subnet_id}'  >> subnetInfo.txt"
    
  }

  network_interface {
    network_interface_id = aws_network_interface.my_nic.id
    device_index         = 0
  }

  credit_specification {
    cpu_credits = "unlimited"
  }
}

########################################################

Create aws EKS by using Terraform 
####################################
main.tf

terraform {
  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = "~> 5.0"
    }
  }
}

# Configure the AWS Provider
provider "aws" {
  region = "us-east-1"
}

resource "aws_eks_cluster" "example" {
  name     = "example"
  role_arn = aws_iam_role.eksClusterRole.arn

  vpc_config {
    subnet_ids = ["subnet-0db93f133f15daf79", "subnet-0874af9b0c91fa50a"]
  } 

  # Ensure that IAM Role permissions are created before and deleted after EKS Cluster handling.
  # Otherwise, EKS will not be able to properly delete EKS managed EC2 infrastructure such as Security Groups.
  depends_on = [
    aws_iam_role_policy_attachment.example-AmazonEKSClusterPolicy,
    aws_iam_role_policy_attachment.example-AmazonEKSVPCResourceController,
  ]
}

output "endpoint" {
  value = aws_eks_cluster.example.endpoint
}

output "kubeconfig-certificate-authority-data" {
  value = aws_eks_cluster.example.certificate_authority[0].data
}

data "aws_iam_policy_document" "assume_role" {
  statement {
    effect = "Allow"

    principals {
      type        = "Service"
      identifiers = ["eks.amazonaws.com"]
    }

    actions = ["sts:AssumeRole"]
  }
}

resource "aws_iam_role" "eksClusterRole" {
  name               = "eksClusterRole"
  assume_role_policy = data.aws_iam_policy_document.assume_role.json
}

resource "aws_iam_role_policy_attachment" "example-AmazonEKSClusterPolicy" {
  policy_arn = "arn:aws:iam::aws:policy/AmazonEKSClusterPolicy"
  role       = aws_iam_role.eksClusterRole.name
}

# Optionally, enable Security Groups for Pods
# Reference: https://docs.aws.amazon.com/eks/latest/userguide/security-groups-for-pods.html
resource "aws_iam_role_policy_attachment" "example-AmazonEKSVPCResourceController" {
  policy_arn = "arn:aws:iam::aws:policy/AmazonEKSVPCResourceController"
  role       = aws_iam_role.eksClusterRole.name
}



#To install KUbectl to access EKS

provider "null" {}

resource "null_resource" "install_kubectl" {
  provisioner "local-exec" {
    command = <<EOT
    # Define the current working directory
    WORKING_DIR=$(pwd)

    # Download the latest kubectl binary to the working directory
    curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"

    # Make it executable
    chmod +x kubectl

    # Move it to the current working directory
    mv kubectl $WORKING_DIR

    # Verify the installation
    ./kubectl version --client
    EOT
  }
}

#Then apply commands
#terraform init 
#terraform apply

#Then  we should update kubeconfig by
aws eks --region us-east-1 update-kubeconfig --name example
#cat /etc/*release to check OS

#if AWS CLI is not installed we should instal aws cli

provider "null" {}

resource "null_resource" "install_aws_cli" {
  provisioner "local-exec" {
    command = <<EOT
    # Define the working directory (optional, typically /tmp or current dir)
    WORKING_DIR=$(pwd)

    # Download the AWS CLI installer (version 2)
    curl "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" -o "awscliv2.zip"

    # Unzip the installer
    unzip awscliv2.zip -d $WORKING_DIR

    # Run the installer
    sudo $WORKING_DIR/aws/install

    # Verify the installation
    aws --version
    EOT
  }
}

output "aws_cli_installation_status" {
  value = "AWS CLI installed successfully"
}



############################################################################

terraform init

Initializes a Terraform working directory.
Downloads provider plugins and sets up the backend configuration.
Run this command first when starting a project.

terraform init
terraform validate

Validates the configuration files for syntax and structural correctness.
Does not interact with infrastructure or state.

terraform validate
terraform plan

Creates an execution plan, showing the changes Terraform will make to your infrastructure.
A safe "dry-run" to review before applying changes.

terraform plan
terraform apply

Applies the changes required to reach the desired state of your configuration.
Prompts for confirmation unless a saved plan file is provided.

terraform apply
terraform destroy

Destroys all resources defined in the configuration.
Useful for cleaning up after testing or decommissioning infrastructure.

This generates a plan where the ex,aws_instance.web resource is marked for destruction and recreation.
terraform plan -replace="resource_type.resource_name

terraform destroy
terraform show

Displays details of the current state or a saved execution plan.

terraform show
terraform output

Extracts and displays values from the output section of your configuration.

terraform output
terraform fmt

Formats Terraform configuration files to follow the standardized style.

terraform fmt
terraform state

Manages the Terraform state file, enabling actions like moving, removing, or importing resources.
Example:


terraform state list   # Lists all resources in the state
terraform state mv     # Moves resources within the state
terraform import

Brings an existing resource into Terraform management by adding it to the state file.

terraform import <resource_name> <real_world_identifier>
terraform refresh

Updates the state file to match the real-world infrastructure without modifying resources.

terraform refresh
terraform workspace

Manages workspaces (isolated state files) for managing multiple environments like dev, test, prod.

terraform workspace list   # List workspaces
terraform workspace new    # Create a new workspace
terraform taint (Deprecated, use terraform apply -replace instead)
Marks a resource for recreation during the next terraform apply.
terraform untaint

Removes the taint marking from a resource, so it won’t be recreated.

terraform untaint <resource_name>
terraform graph

Generates a visual graph of the Terraform resources and their dependencies.
bash
Copy code
terraform graph | dot -Tsvg > graph.svg
terraform login

Authenticates with Terraform Cloud or a private Terraform Enterprise instance.

terraform login
Initialization & Setup: terraform init
Validation: terraform validate
Preview Changes: terraform plan
Apply Changes: terraform apply
Destroy Resources: terraform destroy
Manage State: terraform state
Import Resources: terraform import
Output Management: terraform output
Formatting: terraform fmt
Providers
Definition: Plugins that interact with APIs of cloud providers or other services (e.g., AWS, Azure, Google Cloud).
Example:

provider "aws" {
  region = "us-east-1"
}
###########################
2. Resources
Definition: The basic building blocks in Terraform representing cloud services (e.g., EC2 instances, S3 buckets).
Example:

resource "aws_instance" "example" {
  ami           = "ami-123456"
  instance_type = "t2.micro"
}

#########################################
3. Variables
Definition: Input parameters for Terraform configurations.
Example:

variable "region" {
  default = "us-east-1"
}
Use variables in your configuration:

provider "aws" {
  region = var.region
}

##########################################
4. Outputs
Definition: Display or export useful information about resources after applying configurations.
Example:

output "instance_id" {
  value = aws_instance.example.id
}

##############################################
5. State
Definition: Tracks the real-world state of your resources to allow incremental updates.
State File: Stored locally (terraform.tfstate) or remotely (e.g., S3).
Commands:
terraform state list: View tracked resources.
terraform state rm: Remove a resource from state.

##################################################
6. Modules
Definition: Reusable units of Terraform code that organize and group resources.
Example: Call a module:

module "network" {
  source = "./modules/network"
}
Remote modules from the registry:

module "eks" {
  source  = "terraform-aws-modules/eks/aws"
  version = "19.0.0"
}

####################################################
7. Data Sources
Definition: Fetch information about existing resources to use in your configuration.
Example:

data "aws_ami" "latest" {
  most_recent = true
  owners      = ["amazon"]
  filters = {
    name = "amzn2-ami-hvm-*"
  }
}

###########################################################
8. Provisioners
Definition: Execute scripts or actions on a resource after creation.
Example:

resource "aws_instance" "example" {
  provisioner "local-exec" {
    command = "echo 'Instance created!'"
  }
}

#######################################################
9. Backends
Definition: Store Terraform state remotely for collaboration (e.g., S3, Terraform Cloud).
Example (S3 backend):

terraform {
  backend "s3" {
    bucket = "my-terraform-state"
    key    = "state.tfstate"
    region = "us-east-1"
  }
}

######################################################
Terraform Workflow
1. Write Configuration
Define resources and their dependencies in .tf files.

2. Initialize
Download provider plugins and set up the environment.


terraform init
3. Plan
Preview changes that Terraform will make.
terraform plan

4. Apply
Execute the changes to provision resources.


terraform apply
5. Destroy
Remove all resources defined in the configuration.
terraform destroy

##############################################
Advanced Concepts
1. Terraform Functions
Perform operations within configurations.
Examples:
String manipulation: join(",", ["a", "b", "c"])
Math: max(5, 10)
Logic: lookup(map("key", "value"), "key", "default")

######################################################
2. Terraform Workspaces
Manage multiple environments (e.g., dev, prod) with the same configuration.
Commands:
terraform workspace new dev
terraform workspace select dev
terraform workspace list

######################################################
3. Lifecycle Rules
Manage the creation, update, and deletion of resources.
Example:

resource "aws_instance" "example" {
  lifecycle {
    create_before_destroy = true
  }
}

########################################################
4. Dynamic Blocks
Generate blocks programmatically.
Example:

resource "aws_security_group" "example" {
  dynamic "ingress" {
    for_each = var.ports
    content {
      from_port   = ingress.value
      to_port     = ingress.value
      protocol    = "tcp"
      cidr_blocks = ["0.0.0.0/0"]
    }
  }
}

###################################################
5. Dependency Management
Terraform automatically manages dependencies between resources using implicit references (e.g., aws_vpc.id).

##########################################################
6. Remote Execution
Use Terraform Cloud or Enterprise for remote runs and collaboration.
Terraform Commands
Command	Description
terraform init	Initialize the configuration.
terraform plan	Preview resource changes.
terraform apply	Apply changes to infrastructure.
terraform destroy	Destroy infrastructure.
terraform fmt	Format configuration files.
terraform validate	Validate the syntax of configuration files.
terraform state	Inspect and modify Terraform state.
terraform output	Display output values.
terraform import	Import existing resources into Terraform.
terraform taint	Mark a resource for recreation.
Best Practices
Use Version Control:
Store .tf files in Git.
Remote State Management:
Use backends for collaboration.
Use Modules:
Modularize and reuse code.
Environment Isolation:
Separate configurations or workspaces for dev, staging, prod.
Apply terraform fmt Regularly:
Ensure consistent formatting.
Pin Provider Versions:
Avoid unexpected changes by locking versions:

terraform {
  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = "~> 5.0"
    }
  }
}
Common Challenges
State Conflicts:
Use remote state with locking to prevent overwrites.
Drift Detection:
Use terraform plan regularly to detect manual changes in resources.
Breaking Changes:
Always review module and provider release notes when upgrading versions.

#############################################################
main.tf file
##################
terraform {
  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = "~> 5.0"
    }
  }
}

# Configure the AWS Provider
provider "aws" {
  region = "us-west-2"
}
provider "aws" {
  alias = "west"
  region     = "us-west-2"
  #access_key = "AKIAW3MEAISABWULLWUG"
  secret_key = "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"
}

resource "aws_vpc" "my_vpc" {
    cidr_block = "10.0.0.0/16"
}
resource "aws_subnet" "my_subnet" {
  vpc_id     = aws_vpc.my_vpc.id
  cidr_block = "10.0.1.0/24"
  availability_zone = "us-west-2a"
}

resource "aws_security_group" "allow_tls" {
  name        = "allow_tls"
  description = "Allow TLS inbound traffic and all outbound traffic"
  vpc_id      = aws_vpc.my_vpc.id

  ingress {
    description = "TLS from VPC"
    from_port   = 443
    to_port     = 443
    protocol    = "tcp"
    cidr_blocks = [aws_vpc.my_vpc.cidr_block]
  }
  egress {
    from_port   = 0
    to_port     = 0
    protocol    = "-1"
    cidr_blocks = ["0.0.0.0/0"]
  }
}

resource "aws_network_interface" "my_nic" {
  subnet_id       = aws_subnet.my_subnet.id
  private_ips     = ["10.0.1.50"]
  security_groups = [aws_security_group.allow_tls.id]
}

resource "aws_instance" "my_instance" {
  ami           = "ami-005e54dee72cc1d00" 
  instance_type = "t2.micro"

  network_interface {
    network_interface_id = aws_network_interface.my_nic.id
    device_index         = 0
  }

  credit_specification {
    cpu_credits = "unlimited"
  }
}

###################################3
terraform.tfstate 
###################

    }
  ],
  "check_results": null
}
{
  "version": 4,
  "terraform_version": "1.5.0",
  "serial": 6,
  "lineage": "56644c67-16e3-b96c-25f2-c3bdb6f8d45e",
  "outputs": {},
  "resources": [
    {
      "mode": "managed",
      "type": "aws_instance",
      "name": "my_instance",
      "provider": "provider[\"registry.terraform.io/hashicorp/aws\"]",
      "instances": [
        {
          "schema_version": 1,
          "attributes": {
            "ami": "ami-005e54dee72cc1d00",
            "arn": "arn:aws:ec2:us-west-2:851725482328:instance/i-0a540ef16ade96733",
            "associate_public_ip_address": false,
            "availability_zone": "us-west-2a",
            "capacity_reservation_specification": [
              {
                "capacity_reservation_preference": "open",
                "capacity_reservation_target": []
              }
            ],
            "cpu_core_count": 1,
            "cpu_options": [
              {
                "amd_sev_snp": "",
                "core_count": 1,
                "threads_per_core": 1
              }
            ],
            "cpu_threads_per_core": 1,
            "credit_specification": [
              {
                "cpu_credits": "unlimited"
              }
            ],
            "disable_api_stop": false,
            "disable_api_termination": false,
            "ebs_block_device": [],
            "ebs_optimized": false,
            "enclave_options": [
              {
                "enabled": false
              }
            ],
            "ephemeral_block_device": [],
            "get_password_data": false,
            "hibernation": false,
            "host_id": "",
            "host_resource_group_arn": null,
            "iam_instance_profile": "",
            "id": "i-0a540ef16ade96733",
            "instance_initiated_shutdown_behavior": "stop",
            "instance_lifecycle": "",
            "instance_market_options": [],
            "instance_state": "running",
            "instance_type": "t2.micro",
            "ipv6_address_count": 0,
            "ipv6_addresses": [],
            "key_name": "",
            "launch_template": [],
            "maintenance_options": [
              {
                "auto_recovery": "default"
              }
            ],
            "metadata_options": [
              {
                "http_endpoint": "enabled",
                "http_protocol_ipv6": "disabled",
                "http_put_response_hop_limit": 1,
                "http_tokens": "optional",
                "instance_metadata_tags": "disabled"
              }
            ],
            "monitoring": false,
            "network_interface": [
              {
                "delete_on_termination": false,
                "device_index": 0,
                "network_card_index": 0,
                "network_interface_id": "eni-00439511f7d52b854"
              }
            ],
            "outpost_arn": "",
            "password_data": "",
            "placement_group": "",
            "placement_partition_number": 0,
            "primary_network_interface_id": "eni-00439511f7d52b854",
            "private_dns": "ip-10-0-1-50.us-west-2.compute.internal",
            "private_dns_name_options": [
              {
                "enable_resource_name_dns_a_record": false,
                "enable_resource_name_dns_aaaa_record": false,
                "hostname_type": "ip-name"
              }
            ],
            "private_ip": "10.0.1.50",
            "public_dns": "",
            "public_ip": "",
            "root_block_device": [
              {
                "delete_on_termination": true,
                "device_name": "/dev/sda1",
                "encrypted": false,
                "iops": 100,
                "kms_key_id": "",
                "tags": {},
                "tags_all": {},
                "throughput": 0,
                "volume_id": "vol-03eeb0fe11431199c",
                "volume_size": 8,
                "volume_type": "gp2"
              }
            ],
            "secondary_private_ips": [],
            "security_groups": [],
            "source_dest_check": true,
            "spot_instance_request_id": "",
            "subnet_id": "subnet-0c5c66612bf9496df",
            "tags": null,
            "tags_all": {},
            "tenancy": "default",
            "timeouts": null,
            "user_data": null,
            "user_data_base64": null,
            "user_data_replace_on_change": false,
            "volume_tags": null,
            "vpc_security_group_ids": [
              "sg-0ec595bf37a90fbda"
            ]
          },
          "sensitive_attributes": [],
          "private": "eyJlMmJmYjczMC1lY2FhLTExZTYtOGY4OC0zNDM2M2JjN2M0YzAiOnsiY3JlYXRlIjo2MDAwMDAwMDAwMDAsImRlbGV0ZSI6MTIwMDAwMDAwMDAwMCwicmVhZCI6OTAwMDAwMDAwMDAwLCJ1cGRhdGUiOjYwMDAwMDAwMDAwMH0sInNjaGVtYV92ZXJzaW9uIjoiMSJ9",
          "dependencies": [
            "aws_network_interface.my_nic",
            "aws_security_group.allow_tls",
            "aws_subnet.my_subnet",
            "aws_vpc.my_vpc"
          ]
        }
      ]
    },
    {
      "mode": "managed",
      "type": "aws_network_interface",
      "name": "my_nic",
      "provider": "provider[\"registry.terraform.io/hashicorp/aws\"]",
      "instances": [
        {
          "schema_version": 0,
          "attributes": {
            "arn": "arn:aws:ec2:us-west-2:851725482328:network-interface/eni-00439511f7d52b854",
            "attachment": [],
            "description": "",
            "id": "eni-00439511f7d52b854",
            "interface_type": "interface",
            "ipv4_prefix_count": 0,
            "ipv4_prefixes": [],
            "ipv6_address_count": 0,
            "ipv6_address_list": [],
            "ipv6_address_list_enabled": false,
            "ipv6_addresses": [],
            "ipv6_prefix_count": 0,
            "ipv6_prefixes": [],
            "mac_address": "06:19:52:08:63:c1",
            "outpost_arn": "",
            "owner_id": "851725482328",
            "private_dns_name": "",
            "private_ip": "10.0.1.50",
            "private_ip_list": [
              "10.0.1.50"
            ],
            "private_ip_list_enabled": false,
            "private_ips": [
              "10.0.1.50"
            ],
            "private_ips_count": 0,
            "security_groups": [
              "sg-0ec595bf37a90fbda"
            ],
            "source_dest_check": true,
            "subnet_id": "subnet-0c5c66612bf9496df",
            "tags": null,
            "tags_all": {}
          },
          "sensitive_attributes": [],
          "private": "bnVsbA==",
          "dependencies": [
            "aws_security_group.allow_tls",
            "aws_subnet.my_subnet",
            "aws_vpc.my_vpc"
          ]
        }
      ]
    },
    {
      "mode": "managed",
      "type": "aws_security_group",
      "name": "allow_tls",
      "provider": "provider[\"registry.terraform.io/hashicorp/aws\"]",
      "instances": [
        {
          "schema_version": 1,
          "attributes": {
            "arn": "arn:aws:ec2:us-west-2:851725482328:security-group/sg-0ec595bf37a90fbda",
            "description": "Allow TLS inbound traffic and all outbound traffic",
            "egress": [
              {
                "cidr_blocks": [
                  "0.0.0.0/0"
                ],
                "description": "",
                "from_port": 0,
                "ipv6_cidr_blocks": [],
                "prefix_list_ids": [],
                "protocol": "-1",
                "security_groups": [],
                "self": false,
                "to_port": 0
              }
            ],
            "id": "sg-0ec595bf37a90fbda",
            "ingress": [
              {
                "cidr_blocks": [
                  "10.0.0.0/16"
                ],
                "description": "TLS from VPC",
                "from_port": 443,
                "ipv6_cidr_blocks": [],
                "prefix_list_ids": [],
                "protocol": "tcp",
                "security_groups": [],
                "self": false,
                "to_port": 443
              }
            ],
            "name": "allow_tls",
            "name_prefix": "",
            "owner_id": "851725482328",
            "revoke_rules_on_delete": false,
            "tags": null,
            "tags_all": {},
            "timeouts": null,
            "vpc_id": "vpc-0596e12b409f8c5f3"
          },
          "sensitive_attributes": [],
          "private": "eyJlMmJmYjczMC1lY2FhLTExZTYtOGY4OC0zNDM2M2JjN2M0YzAiOnsiY3JlYXRlIjo2MDAwMDAwMDAwMDAsImRlbGV0ZSI6OTAwMDAwMDAwMDAwfSwic2NoZW1hX3ZlcnNpb24iOiIxIn0=",
          "dependencies": [
            "aws_vpc.my_vpc"
          ]
        }
      ]
    },
    {
      "mode": "managed",
      "type": "aws_subnet",
      "name": "my_subnet",
      "provider": "provider[\"registry.terraform.io/hashicorp/aws\"]",
      "instances": [
        {
          "schema_version": 1,
          "attributes": {
            "arn": "arn:aws:ec2:us-west-2:851725482328:subnet/subnet-0c5c66612bf9496df",
            "assign_ipv6_address_on_creation": false,
            "availability_zone": "us-west-2a",
            "availability_zone_id": "usw2-az2",
            "cidr_block": "10.0.1.0/24",
            "customer_owned_ipv4_pool": "",
            "enable_dns64": false,
            "enable_lni_at_device_index": 0,
            "enable_resource_name_dns_a_record_on_launch": false,
            "enable_resource_name_dns_aaaa_record_on_launch": false,
            "id": "subnet-0c5c66612bf9496df",
            "ipv6_cidr_block": "",
            "ipv6_cidr_block_association_id": "",
            "ipv6_native": false,
            "map_customer_owned_ip_on_launch": false,
            "map_public_ip_on_launch": false,
            "outpost_arn": "",
            "owner_id": "851725482328",
            "private_dns_hostname_type_on_launch": "ip-name",
            "tags": null,
            "tags_all": {},
            "timeouts": null,
            "vpc_id": "vpc-0596e12b409f8c5f3"
          },
          "sensitive_attributes": [],
          "private": "eyJlMmJmYjczMC1lY2FhLTExZTYtOGY4OC0zNDM2M2JjN2M0YzAiOnsiY3JlYXRlIjo2MDAwMDAwMDAwMDAsImRlbGV0ZSI6MTIwMDAwMDAwMDAwMH0sInNjaGVtYV92ZXJzaW9uIjoiMSJ9",
          "dependencies": [
            "aws_vpc.my_vpc"
          ]
        }
      ]
    },
    {
      "mode": "managed",
      "type": "aws_vpc",
      "name": "my_vpc",
      "provider": "provider[\"registry.terraform.io/hashicorp/aws\"]",
      "instances": [
        {
          "schema_version": 1,
          "attributes": {
            "arn": "arn:aws:ec2:us-west-2:851725482328:vpc/vpc-0596e12b409f8c5f3",
            "assign_generated_ipv6_cidr_block": false,
            "cidr_block": "10.0.0.0/16",
            "default_network_acl_id": "acl-04cd693f6eda975a3",
            "default_route_table_id": "rtb-0d7e11d3a8cddf457",
            "default_security_group_id": "sg-0ecd747e181956f25",
            "dhcp_options_id": "dopt-0d9b83a2c5a8ac141",
            "enable_dns_hostnames": false,
            "enable_dns_support": true,
            "enable_network_address_usage_metrics": false,
            "id": "vpc-0596e12b409f8c5f3",
            "instance_tenancy": "default",
            "ipv4_ipam_pool_id": null,
            "ipv4_netmask_length": null,
            "ipv6_association_id": "",
            "ipv6_cidr_block": "",
            "ipv6_cidr_block_network_border_group": "",
            "ipv6_ipam_pool_id": "",
            "ipv6_netmask_length": 0,
            "main_route_table_id": "rtb-0d7e11d3a8cddf457",
            "owner_id": "851725482328",
            "tags": null,
            "tags_all": {}
          },
          "sensitive_attributes": [],
          "private": "eyJzY2hlbWFfdmVyc2lvbiI6IjEifQ=="
        }
      ]


#####################################################################################
variable.tf ,this file for modules
##################
variable "rgname" {
    type = string
    description = "used for naming resource group"
}

variable "location" {
    type = string 
    description = "used for selecting location"
}

variable "prefix" {
    type = string
    description = "The prefix used for all resources in this example"
}

variable "my_vpc" {
    type = string
    description = "this variable defines vpc"
}

variable "my_subnet" {
    type = string
    description = "defines subnet"
}

#########################################################
modules
dev.tf
###################
terraform {
  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = "~> 5.0"
    }
  }
}


module "module_dev" {
    location = "west-us-2"
    source = "./modules"
    prefix = "dev"
    my_vpc = "10.0.0.0/16"
    my_subnet = "10.0.1.0/24"
    rgname = "DevRG"
    
    
}

##########################3
prod.tf
#################

module "module_prod" {
    location = "west-us-2"
    source = "./modules"
    prefix = "prod"
    rgname = "ProdRG"
     my_vpc = "10.30.0.0/16"
    my_subnet = "10.30.1.0/24"
}

###########################
uat.tf
######################

module "module_uat" {
    location = "west-us-2"
    source = "./modules"
    prefix = "Uat"
    rgname = "UatRG"
    my_vpc = "10.40.0.0/16"
    my_subnet = "10.40.1.0/24"
}

#######################################
Backend or Remote state

terraform {
  backend "s3" {
    bucket = "mybucket"
    key    = "path/to/my/key"
    region = "us-east-1"
  }
}
#########################################
Create S3 bucket

resource "aws_s3_bucket" "example" {
  bucket = "my-tf-test-bucket"

  tags = {
    Name        = "My bucket"
    Environment = "Dev"
  }
}
###############################################
DynamoDB table:

resource "aws_dynamodb_table" "basic-dynamodb-table" {
  name           = "Statelock"
  billing_mode   = "PROVISIONED"
  read_capacity  = 20
  write_capacity = 20
  hash_key       = "UserId"
  range_key      = "GameTitle"

  attribute {
    name = "UserId"
    type = "S"
  }

  attribute {
    name = "GameTitle"
    type = "S"
  }

  attribute {
    name = "TopScore"
    type = "N"
  }

  ttl {
    attribute_name = "TimeToExist"
    enabled        = true
  }

  global_secondary_index {
    name               = "GameTitleIndex"
    hash_key           = "GameTitle"
    range_key          = "TopScore"
    write_capacity     = 10
    read_capacity      = 10
    projection_type    = "INCLUDE"
    non_key_attributes = ["UserId"]
  }

  tags = {
    Name        = "dynamodb-table-1"
    Environment = "production"
  }
}
############################################################
Data sources

data "aws_instance" "foo" {
  instance_id = "i-instanceid"

  filter {
    name   = "image-id"
    values = ["ami-xxxxxxxx"]
  }

  filter {
    name   = "tag:Name"
    values = ["instance-name-tag"]
  }
}
#################################################
LOcals:

locals {
  host        = aws_eks_cluster.example_0.endpoint
  certificate = base64decode(aws_eks_cluster.example_0.certificate_authority.data)
}

provider "helm" {
  kubernetes {
    host                   = local.host
    cluster_ca_certificate = local.certificate
    # exec allows for an authentication command to be run to obtain user
    # credentials rather than having them stored directly in the file
    exec {
      api_version = "client.authentication.k8s.io/v1beta1"
      args        = ["eks", "get-token", "--cluster-name", aws_eks_cluster.example_0.name]
      command     = "aws"
    }
  }
}

######################################################
File Provisioner:
#####
resource "aws_instance" "web" {
  # ...

  # Copies the myapp.conf file to /etc/myapp.conf
  provisioner "file" {
    source      = "conf/myapp.conf"
    destination = "/etc/myapp.conf"
  }

  # Copies the string in content into /tmp/file.log
  provisioner "file" {
    content     = "ami used: ${self.ami}"
    destination = "/tmp/file.log"
  }

  # Copies the configs.d folder to /etc/configs.d
  provisioner "file" {
    source      = "conf/configs.d"
    destination = "/etc"
  }

  # Copies all files and folders in apps/app1 to D:/IIS/webapp1
  provisioner "file" {
    source      = "apps/app1/"
    destination = "D:/IIS/webapp1"
  }
}
#######################################################
Local-exec Provisioner

resource "aws_instance" "web" {
  # ...

  provisioner "local-exec" {
    command = "echo ${self.private_ip} >> private_ips.txt"
  }
}

###############################################################
Remote-exec Provisioner

resource "aws_instance" "web" {
  # ...

  # Establishes connection to be used by all
  # generic remote provisioners (i.e. file/remote-exec)
  connection {
    type     = "ssh"
    user     = "root"
    password = var.root_password
    host     = self.public_ip
  }

  provisioner "remote-exec" {
    inline = [
      "puppet apply",
      "consul join ${aws_instance.web.private_ip}",
    ]
  }
}

##############################################################
Terraform workspaces:

main.tf
dev.tfvars
prod.tfvars
variables.tf

to create new workspace ---->terraform workspace new dev
and switched to dev 

to show workspaces ---> terraform workspace list
same for prod
swiches to another env ----> terraform workspace select dev
then terraform init
terraform apply -var-file dev.tfvars

####################################################################
Terraform with DynamoDB:

resource "aws_dynamodb_table" "project_sapphire_inventory" {
  name           = "inventory"
  billing_mode   = "PAY_PER_REQUEST"
  hash_key       = "AssetID"

  attribute {
    name = "AssetID"
    type = "N"
  }
  attribute {
    name = "AssetName"
    type = "S"
  }
  attribute {
    name = "age"
    type = "N"
  }
  attribute {
    name = "Hardware"
    type = "B"
  }
  global_secondary_index {
    name             = "AssetName"
    hash_key         = "AssetName"
    projection_type    = "ALL"

  }
  global_secondary_index {
    name             = "age"
    hash_key         = "age"
    projection_type    = "ALL"

  }
  global_secondary_index {
    name             = "Hardware"
    hash_key         = "Hardware"
    projection_type    = "ALL"

  }
}
resource "aws_dynamodb_table_item" "upload" {
  table_name = aws_dynamodb_table.project_sapphire_inventory.name
  hash_key   = aws_dynamodb_table.project_sapphire_inventory.hash_key
  item = <<EOF
 {
  "AssetID": {"N": "1"},
  "AssetName": {"S": "printer"},
  "age": {"N": "5"},
  "Hardware": {"B": "true" }
}
EOF
}

##############################################################
Terraform with S3

resource "aws_s3_bucket" "dc_bucket" {
  bucket = "dc_is_better_than_marvel"
  }

resource "aws_s3_object" "upload" {
  bucket = "pixar-studios-2020"
  key    = "woody.jpg"
  source = "/root/woody.jpg"
}
#############################################################
Terraform with IAM

resource "aws_iam_user" "users" {
     name = "mary"
     region = "us-east-1"
}

update the iam-user.tf to make use of the count meta-argument to loop through the project-sapphire-users variable and create all the users in the list.

resource "aws_iam_user" "users" {
     name = var.project-sapphire-users[count.index]
     count = length(var.project-sapphire-users)
}

#######################################################################
Terraform Modules

Terraform modules are reusable blocks of configuration that allow you to define and manage multiple infrastructure resources as a single unit. 
They enable you to break down complex infrastructure deployments into smaller, more manageable pieces, promoting modularity and reusability.


A module for creating a virtual private cloud (VPC) with subnets and security groups
A module for provisioning a database cluster with scaling and backup policies
A module for deploying a load balancer with auto-scaling and SSL termination
By using Terraform modules, you can speed up your infrastructure deployments, reduce errors, and improve maintainability.

What is a Terraform module? A Terraform module is a collection of standard configuration files in a dedicated directory. 
Terraform modules encapsulate groups of resources dedicated to one task,
reducing the amount of code you have to develop for similar infrastructure components.

module "iam_iam-user" {
  source  = "terraform-aws-modules/iam/aws//modules/iam-user"
  version = "5.28.0"
  # insert the 1 required variable here
  name = "sai"
}

#######################################################################
Using Provisioners:

terraform {
  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = "~> 5.0"
    }
  }
}

# Configure the AWS Provider
provider "aws" {
  region = "us-west-2"
}
provider "aws" {
  alias = "west"
  region     = "us-west-2"
  #access_key = "AKIAW3MEAISABWULLWUG"
  secret_key = "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"
}

resource "aws_vpc" "my_vpc" {
    cidr_block = "10.0.0.0/16"
}
resource "aws_subnet" "my_subnet" {
  vpc_id     = aws_vpc.my_vpc.id
  cidr_block = "10.0.1.0/24"
  availability_zone = "us-west-2a"
}

resource "aws_security_group" "allow_tls" {
  name        = "allow_tls"
  description = "Allow TLS inbound traffic and all outbound traffic"
  vpc_id      = aws_vpc.my_vpc.id

  ingress {
    description = "TLS from VPC"
    from_port   = 443
    to_port     = 443
    protocol    = "tcp"
    cidr_blocks = [aws_vpc.my_vpc.cidr_block]
  }
  egress {
    from_port   = 0
    to_port     = 0
    protocol    = "-1"
    cidr_blocks = ["0.0.0.0/0"]
  }
}

resource "aws_network_interface" "my_nic" {
  subnet_id       = aws_subnet.my_subnet.id
  private_ips     = ["10.0.1.50"]
  security_groups = [aws_security_group.allow_tls.id]
}

resource "aws_instance" "my_instance" {
  ami           = "ami-005e54dee72cc1d00" 
  instance_type = "t2.micro"

  tags = {
    name = "sai_instance"
  }

  provisioner "local-exec" {
    command =  "echo 'subnetID: ${self.subnet_id}'  >> subnetInfo.txt"
    
  }

  network_interface {
    network_interface_id = aws_network_interface.my_nic.id
    device_index         = 0
  }

  credit_specification {
    cpu_credits = "unlimited"
  }
}

########################################################

Create aws EKS by using Terraform 
####################################
main.tf

terraform {
  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = "~> 5.0"
    }
  }
}

# Configure the AWS Provider
provider "aws" {
  region = "us-east-1"
}

resource "aws_eks_cluster" "example" {
  name     = "example"
  role_arn = aws_iam_role.eksClusterRole.arn

  vpc_config {
    subnet_ids = ["subnet-0db93f133f15daf79", "subnet-0874af9b0c91fa50a"]
  } 

  # Ensure that IAM Role permissions are created before and deleted after EKS Cluster handling.
  # Otherwise, EKS will not be able to properly delete EKS managed EC2 infrastructure such as Security Groups.
  depends_on = [
    aws_iam_role_policy_attachment.example-AmazonEKSClusterPolicy,
    aws_iam_role_policy_attachment.example-AmazonEKSVPCResourceController,
  ]
}

output "endpoint" {
  value = aws_eks_cluster.example.endpoint
}

output "kubeconfig-certificate-authority-data" {
  value = aws_eks_cluster.example.certificate_authority[0].data
}

data "aws_iam_policy_document" "assume_role" {
  statement {
    effect = "Allow"

    principals {
      type        = "Service"
      identifiers = ["eks.amazonaws.com"]
    }

    actions = ["sts:AssumeRole"]
  }
}

resource "aws_iam_role" "eksClusterRole" {
  name               = "eksClusterRole"
  assume_role_policy = data.aws_iam_policy_document.assume_role.json
}

resource "aws_iam_role_policy_attachment" "example-AmazonEKSClusterPolicy" {
  policy_arn = "arn:aws:iam::aws:policy/AmazonEKSClusterPolicy"
  role       = aws_iam_role.eksClusterRole.name
}

# Optionally, enable Security Groups for Pods
# Reference: https://docs.aws.amazon.com/eks/latest/userguide/security-groups-for-pods.html
resource "aws_iam_role_policy_attachment" "example-AmazonEKSVPCResourceController" {
  policy_arn = "arn:aws:iam::aws:policy/AmazonEKSVPCResourceController"
  role       = aws_iam_role.eksClusterRole.name
}



#To install KUbectl to access EKS

provider "null" {}

resource "null_resource" "install_kubectl" {
  provisioner "local-exec" {
    command = <<EOT
    # Define the current working directory
    WORKING_DIR=$(pwd)

    # Download the latest kubectl binary to the working directory
    curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"

    # Make it executable
    chmod +x kubectl

    # Move it to the current working directory
    mv kubectl $WORKING_DIR

    # Verify the installation
    ./kubectl version --client
    EOT
  }
}

#Then apply commands
#terraform init 
#terraform apply

#Then  we should update kubeconfig by
aws eks --region us-east-1 update-kubeconfig --name example
#cat /etc/*release to check OS

#if AWS CLI is not installed we should instal aws cli

provider "null" {}

resource "null_resource" "install_aws_cli" {
  provisioner "local-exec" {
    command = <<EOT
    # Define the working directory (optional, typically /tmp or current dir)
    WORKING_DIR=$(pwd)

    # Download the AWS CLI installer (version 2)
    curl "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" -o "awscliv2.zip"

    # Unzip the installer
    unzip awscliv2.zip -d $WORKING_DIR

    # Run the installer
    sudo $WORKING_DIR/aws/install

    # Verify the installation
    aws --version
    EOT
  }
}

output "aws_cli_installation_status" {
  value = "AWS CLI installed successfully"
}



############################################################################

terraform init

Initializes a Terraform working directory.
Downloads provider plugins and sets up the backend configuration.
Run this command first when starting a project.

terraform init
terraform validate

Validates the configuration files for syntax and structural correctness.
Does not interact with infrastructure or state.

terraform validate
terraform plan

Creates an execution plan, showing the changes Terraform will make to your infrastructure.
A safe "dry-run" to review before applying changes.

terraform plan
terraform apply

Applies the changes required to reach the desired state of your configuration.
Prompts for confirmation unless a saved plan file is provided.

terraform apply
terraform destroy

Destroys all resources defined in the configuration.
Useful for cleaning up after testing or decommissioning infrastructure.

This generates a plan where the ex,aws_instance.web resource is marked for destruction and recreation.
terraform plan -replace="resource_type.resource_name

terraform destroy
terraform show

Displays details of the current state or a saved execution plan.

terraform show
terraform output

Extracts and displays values from the output section of your configuration.

terraform output
terraform fmt

Formats Terraform configuration files to follow the standardized style.

terraform fmt
terraform state

Manages the Terraform state file, enabling actions like moving, removing, or importing resources.
Example:


terraform state list   # Lists all resources in the state
terraform state mv     # Moves resources within the state
terraform import

Brings an existing resource into Terraform management by adding it to the state file.

terraform import <resource_name> <real_world_identifier>
terraform refresh

Updates the state file to match the real-world infrastructure without modifying resources.

terraform refresh
terraform workspace

Manages workspaces (isolated state files) for managing multiple environments like dev, test, prod.

terraform workspace list   # List workspaces
terraform workspace new    # Create a new workspace
terraform taint (Deprecated, use terraform apply -replace instead)
Marks a resource for recreation during the next terraform apply.
terraform untaint

Removes the taint marking from a resource, so it won’t be recreated.

terraform untaint <resource_name>
terraform graph

Generates a visual graph of the Terraform resources and their dependencies.
bash
Copy code
terraform graph | dot -Tsvg > graph.svg
terraform login

Authenticates with Terraform Cloud or a private Terraform Enterprise instance.

terraform login
Initialization & Setup: terraform init
Validation: terraform validate
Preview Changes: terraform plan
Apply Changes: terraform apply
Destroy Resources: terraform destroy
Manage State: terraform state
Import Resources: terraform import
Output Management: terraform output
Formatting: terraform fmt
